{"ast":null,"code":"\"use client\";\n\nvar _s = $RefreshSig$();\nimport { animate } from \"framer-motion\";\nimport { useEffect, useState, useRef } from \"react\";\nexport function useAnimatedText(text, delimiter = \"\", speedPerPart = 0.12) {\n  _s();\n  const [displayedIndex, setDisplayedIndex] = useState(0);\n  const prevTextRef = useRef(\"\");\n  const displayedIndexRef = useRef(0);\n  const animationControlsRef = useRef(null);\n\n  // Keep displayedIndexRef in sync\n  useEffect(() => {\n    displayedIndexRef.current = displayedIndex;\n  }, [displayedIndex]);\n  useEffect(() => {\n    // Handle empty text\n    if (!text) {\n      if (prevTextRef.current.length > 0) {\n        setDisplayedIndex(0);\n        displayedIndexRef.current = 0;\n        prevTextRef.current = \"\";\n        if (animationControlsRef.current) {\n          animationControlsRef.current.stop();\n          animationControlsRef.current = null;\n        }\n      }\n      return;\n    }\n\n    // If text hasn't changed, do nothing\n    if (text === prevTextRef.current) {\n      return;\n    }\n    const prevText = prevTextRef.current;\n    const parts = text.split(delimiter).filter(p => p.length > 0);\n    if (parts.length === 0) {\n      prevTextRef.current = text;\n      return;\n    }\n\n    // Check if this is incremental text (new text starts with previous)\n    let startIndex = 0;\n    if (text.startsWith(prevText) && prevText.length > 0) {\n      // Incremental update - continue from current displayed position\n      startIndex = Math.min(displayedIndexRef.current, parts.length);\n    } else {\n      // New text (not incremental) - start from beginning\n      startIndex = 0;\n      setDisplayedIndex(0);\n      displayedIndexRef.current = 0;\n    }\n    const targetIndex = parts.length;\n    const remainingParts = targetIndex - startIndex;\n    if (remainingParts <= 0) {\n      // Already at target, just update ref\n      if (displayedIndex !== targetIndex) {\n        setDisplayedIndex(targetIndex);\n        displayedIndexRef.current = targetIndex;\n      }\n      prevTextRef.current = text;\n      return;\n    }\n\n    // Stop existing animation\n    if (animationControlsRef.current) {\n      animationControlsRef.current.stop();\n    }\n\n    // Use the speedPerPart parameter passed in\n    const durationPerPart = speedPerPart;\n\n    // Cap the duration so it doesn't take too long, but ensure minimum for smoothness\n    const calculatedDuration = remainingParts * durationPerPart;\n    const duration = Math.max(Math.min(calculatedDuration, 2), 0.1); // Max 2s, min 100ms (faster bounds)\n\n    console.log(`[AnimatedText] Animating ${remainingParts} parts (${startIndex} -> ${targetIndex}), duration: ${duration.toFixed(2)}s`);\n    const controls = animate(startIndex, targetIndex, {\n      duration: duration,\n      ease: \"linear\",\n      // Linear for consistent word-by-word display\n      onUpdate(latest) {\n        const currentIndex = Math.floor(latest);\n        setDisplayedIndex(currentIndex);\n        displayedIndexRef.current = currentIndex;\n      },\n      onComplete: () => {\n        setDisplayedIndex(targetIndex);\n        displayedIndexRef.current = targetIndex;\n        console.log(`[AnimatedText] Animation complete, displayed ${targetIndex} parts`);\n      }\n    });\n    animationControlsRef.current = controls;\n    prevTextRef.current = text;\n    return () => {\n      if (controls) {\n        controls.stop();\n      }\n      animationControlsRef.current = null;\n    };\n  }, [text, delimiter, speedPerPart]);\n\n  // Return the displayed portion of text\n  const parts = text.split(delimiter).filter(p => p.length > 0);\n  return parts.slice(0, displayedIndex).join(delimiter);\n}\n_s(useAnimatedText, \"x+92KxA5czObZ24/dfCbfH8SUrs=\");","map":{"version":3,"names":["_s","$RefreshSig$","animate","useEffect","useState","useRef","useAnimatedText","text","delimiter","speedPerPart","displayedIndex","setDisplayedIndex","prevTextRef","displayedIndexRef","animationControlsRef","current","length","stop","prevText","parts","split","filter","p","startIndex","startsWith","Math","min","targetIndex","remainingParts","durationPerPart","calculatedDuration","duration","max","console","log","toFixed","controls","ease","onUpdate","latest","currentIndex","floor","onComplete","slice","join"],"sources":["C:/Users/josep/OneDrive/Documents/Jason/EyeQ MLR Agent/alcon-mlr-agent/web-interface/src/components/ui/animated-text.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { animate } from \"framer-motion\";\r\nimport { useEffect, useState, useRef } from \"react\";\r\n\r\nexport function useAnimatedText(text: string, delimiter: string = \"\", speedPerPart: number = 0.12) {\r\n  const [displayedIndex, setDisplayedIndex] = useState(0);\r\n  const prevTextRef = useRef(\"\");\r\n  const displayedIndexRef = useRef(0);\r\n  const animationControlsRef = useRef<ReturnType<typeof animate> | null>(null);\r\n\r\n  // Keep displayedIndexRef in sync\r\n  useEffect(() => {\r\n    displayedIndexRef.current = displayedIndex;\r\n  }, [displayedIndex]);\r\n\r\n  useEffect(() => {\r\n    // Handle empty text\r\n    if (!text) {\r\n      if (prevTextRef.current.length > 0) {\r\n        setDisplayedIndex(0);\r\n        displayedIndexRef.current = 0;\r\n        prevTextRef.current = \"\";\r\n        if (animationControlsRef.current) {\r\n          animationControlsRef.current.stop();\r\n          animationControlsRef.current = null;\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    // If text hasn't changed, do nothing\r\n    if (text === prevTextRef.current) {\r\n      return;\r\n    }\r\n\r\n    const prevText = prevTextRef.current;\r\n    const parts = text.split(delimiter).filter(p => p.length > 0);\r\n    \r\n    if (parts.length === 0) {\r\n      prevTextRef.current = text;\r\n      return;\r\n    }\r\n\r\n    // Check if this is incremental text (new text starts with previous)\r\n    let startIndex = 0;\r\n    if (text.startsWith(prevText) && prevText.length > 0) {\r\n      // Incremental update - continue from current displayed position\r\n      startIndex = Math.min(displayedIndexRef.current, parts.length);\r\n    } else {\r\n      // New text (not incremental) - start from beginning\r\n      startIndex = 0;\r\n      setDisplayedIndex(0);\r\n      displayedIndexRef.current = 0;\r\n    }\r\n\r\n    const targetIndex = parts.length;\r\n    const remainingParts = targetIndex - startIndex;\r\n\r\n    if (remainingParts <= 0) {\r\n      // Already at target, just update ref\r\n      if (displayedIndex !== targetIndex) {\r\n        setDisplayedIndex(targetIndex);\r\n        displayedIndexRef.current = targetIndex;\r\n      }\r\n      prevTextRef.current = text;\r\n      return;\r\n    }\r\n\r\n    // Stop existing animation\r\n    if (animationControlsRef.current) {\r\n      animationControlsRef.current.stop();\r\n    }\r\n\r\n    // Use the speedPerPart parameter passed in\r\n    const durationPerPart = speedPerPart;\r\n    \r\n    // Cap the duration so it doesn't take too long, but ensure minimum for smoothness\r\n    const calculatedDuration = remainingParts * durationPerPart;\r\n    const duration = Math.max(Math.min(calculatedDuration, 2), 0.1); // Max 2s, min 100ms (faster bounds)\r\n    \r\n    console.log(`[AnimatedText] Animating ${remainingParts} parts (${startIndex} -> ${targetIndex}), duration: ${duration.toFixed(2)}s`);\r\n\r\n    const controls = animate(startIndex, targetIndex, {\r\n      duration: duration,\r\n      ease: \"linear\", // Linear for consistent word-by-word display\r\n      onUpdate(latest) {\r\n        const currentIndex = Math.floor(latest);\r\n        setDisplayedIndex(currentIndex);\r\n        displayedIndexRef.current = currentIndex;\r\n      },\r\n      onComplete: () => {\r\n        setDisplayedIndex(targetIndex);\r\n        displayedIndexRef.current = targetIndex;\r\n        console.log(`[AnimatedText] Animation complete, displayed ${targetIndex} parts`);\r\n      }\r\n    });\r\n\r\n    animationControlsRef.current = controls;\r\n    prevTextRef.current = text;\r\n\r\n    return () => {\r\n      if (controls) {\r\n        controls.stop();\r\n      }\r\n      animationControlsRef.current = null;\r\n    };\r\n  }, [text, delimiter, speedPerPart]);\r\n\r\n  // Return the displayed portion of text\r\n  const parts = text.split(delimiter).filter(p => p.length > 0);\r\n  return parts.slice(0, displayedIndex).join(delimiter);\r\n}\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}