{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\r\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\r\n * @typedef {import('micromark-util-types').Token} Token\r\n */\n\n// An opening or closing tag start, followed by a case-insensitive specific tag name,\n// followed by HTML whitespace, a greater than, or a slash.\nconst reFlow = /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\\t\\n\\f\\r />])/gi;\n\n// As HTML (text) parses tags separately (and very strictly), we don’t need to be\n// global.\nconst reText = new RegExp('^' + reFlow.source, 'i');\n\n/**\r\n * Extension for `micromark` that can be passed in `htmlExtensions`, to\r\n * support GitHub’s weird and useless tagfilter when serializing to HTML.\r\n *\r\n * @type {HtmlExtension}\r\n */\nexport const gfmTagfilterHtml = {\n  exit: {\n    htmlFlowData(token) {\n      exitHtmlData.call(this, token, reFlow);\n    },\n    htmlTextData(token) {\n      exitHtmlData.call(this, token, reText);\n    }\n  }\n};\n\n/**\r\n * @this {CompileContext}\r\n * @param {Token} token\r\n * @param {RegExp} filter\r\n */\nfunction exitHtmlData(token, filter) {\n  let value = this.sliceSerialize(token);\n  if (this.options.allowDangerousHtml) {\n    value = value.replace(filter, '&lt;$1$2');\n  }\n  this.raw(this.encode(value));\n}","map":{"version":3,"names":["reFlow","reText","RegExp","source","gfmTagfilterHtml","exit","htmlFlowData","token","exitHtmlData","call","htmlTextData","filter","value","sliceSerialize","options","allowDangerousHtml","replace","raw","encode"],"sources":["C:/Users/josep/OneDrive/Documents/Jason/EyeQ MLR Agent/alcon-mlr-agent/web-interface/node_modules/micromark-extension-gfm-tagfilter/index.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\r\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\r\n * @typedef {import('micromark-util-types').Token} Token\r\n */\r\n\r\n// An opening or closing tag start, followed by a case-insensitive specific tag name,\r\n// followed by HTML whitespace, a greater than, or a slash.\r\nconst reFlow =\r\n  /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\\t\\n\\f\\r />])/gi\r\n\r\n// As HTML (text) parses tags separately (and very strictly), we don’t need to be\r\n// global.\r\nconst reText = new RegExp('^' + reFlow.source, 'i')\r\n\r\n/**\r\n * Extension for `micromark` that can be passed in `htmlExtensions`, to\r\n * support GitHub’s weird and useless tagfilter when serializing to HTML.\r\n *\r\n * @type {HtmlExtension}\r\n */\r\nexport const gfmTagfilterHtml = {\r\n  exit: {\r\n    htmlFlowData(token) {\r\n      exitHtmlData.call(this, token, reFlow)\r\n    },\r\n    htmlTextData(token) {\r\n      exitHtmlData.call(this, token, reText)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @param {Token} token\r\n * @param {RegExp} filter\r\n */\r\nfunction exitHtmlData(token, filter) {\r\n  let value = this.sliceSerialize(token)\r\n\r\n  if (this.options.allowDangerousHtml) {\r\n    value = value.replace(filter, '&lt;$1$2')\r\n  }\r\n\r\n  this.raw(this.encode(value))\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAMA,MAAM,GACV,8FAA8F;;AAEhG;AACA;AACA,MAAMC,MAAM,GAAG,IAAIC,MAAM,CAAC,GAAG,GAAGF,MAAM,CAACG,MAAM,EAAE,GAAG,CAAC;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,GAAG;EAC9BC,IAAI,EAAE;IACJC,YAAYA,CAACC,KAAK,EAAE;MAClBC,YAAY,CAACC,IAAI,CAAC,IAAI,EAAEF,KAAK,EAAEP,MAAM,CAAC;IACxC,CAAC;IACDU,YAAYA,CAACH,KAAK,EAAE;MAClBC,YAAY,CAACC,IAAI,CAAC,IAAI,EAAEF,KAAK,EAAEN,MAAM,CAAC;IACxC;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,SAASO,YAAYA,CAACD,KAAK,EAAEI,MAAM,EAAE;EACnC,IAAIC,KAAK,GAAG,IAAI,CAACC,cAAc,CAACN,KAAK,CAAC;EAEtC,IAAI,IAAI,CAACO,OAAO,CAACC,kBAAkB,EAAE;IACnCH,KAAK,GAAGA,KAAK,CAACI,OAAO,CAACL,MAAM,EAAE,UAAU,CAAC;EAC3C;EAEA,IAAI,CAACM,GAAG,CAAC,IAAI,CAACC,MAAM,CAACN,KAAK,CAAC,CAAC;AAC9B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}