{"ast":null,"code":"\"use client\";\n\nvar _s = $RefreshSig$();\nimport { animate } from \"framer-motion\";\nimport { useEffect, useState, useRef } from \"react\";\nexport function useAnimatedText(text, delimiter = \"\") {\n  _s();\n  const [cursor, setCursor] = useState(0);\n  const [startingCursor, setStartingCursor] = useState(0);\n  const prevTextRef = useRef(text);\n  const cursorRef = useRef(0);\n  const animationControlsRef = useRef(null);\n\n  // Keep cursor ref in sync\n  useEffect(() => {\n    cursorRef.current = cursor;\n  }, [cursor]);\n  useEffect(() => {\n    // Handle empty text\n    if (!text) {\n      setCursor(0);\n      setStartingCursor(0);\n      prevTextRef.current = '';\n      if (animationControlsRef.current) {\n        animationControlsRef.current.stop();\n        animationControlsRef.current = null;\n      }\n      return;\n    }\n    const prevText = prevTextRef.current;\n    const parts = text.split(delimiter);\n\n    // Update starting cursor when text changes incrementally\n    let newStartingCursor = startingCursor;\n    if (prevText !== text) {\n      // If new text starts with previous text, continue from current cursor\n      // Otherwise, reset to beginning\n      newStartingCursor = text.startsWith(prevText) ? cursorRef.current : 0;\n      setStartingCursor(newStartingCursor);\n      prevTextRef.current = text;\n    }\n    const remainingParts = parts.length - newStartingCursor;\n    if (remainingParts <= 0) {\n      setCursor(parts.length);\n      return;\n    }\n\n    // Stop any existing animation\n    if (animationControlsRef.current) {\n      animationControlsRef.current.stop();\n    }\n\n    // Calculate duration per part (in seconds) - slower for smoother animation\n    const durationPerPart = delimiter === \"\" ? 0.015 :\n    // Character: 15ms per character\n    delimiter === \" \" ? 0.1 :\n    // Word: 100ms per word (smooth reading speed)\n    0.4; // Chunk: 400ms per chunk\n\n    // Total duration based on remaining parts\n    // Cap at reasonable maximum to avoid very long animations\n    const totalDuration = Math.min(remainingParts * durationPerPart, 15);\n    const controls = animate(newStartingCursor, parts.length, {\n      duration: totalDuration,\n      ease: \"easeOut\",\n      onUpdate(latest) {\n        setCursor(Math.floor(latest));\n      }\n    });\n    animationControlsRef.current = controls;\n    return () => {\n      if (controls) {\n        controls.stop();\n      }\n      animationControlsRef.current = null;\n    };\n  }, [text, delimiter, startingCursor]);\n  return text.split(delimiter).slice(0, cursor).join(delimiter);\n}\n_s(useAnimatedText, \"dABF74H99COryRQkFeYc2S7sGT8=\");","map":{"version":3,"names":["_s","$RefreshSig$","animate","useEffect","useState","useRef","useAnimatedText","text","delimiter","cursor","setCursor","startingCursor","setStartingCursor","prevTextRef","cursorRef","animationControlsRef","current","stop","prevText","parts","split","newStartingCursor","startsWith","remainingParts","length","durationPerPart","totalDuration","Math","min","controls","duration","ease","onUpdate","latest","floor","slice","join"],"sources":["C:/Users/josep/OneDrive/Documents/Jason/EyeQ MLR Agent/alcon-mlr-agent/web-interface/src/components/ui/animated-text.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { animate } from \"framer-motion\";\r\nimport { useEffect, useState, useRef } from \"react\";\r\n\r\nexport function useAnimatedText(text: string, delimiter: string = \"\") {\r\n  const [cursor, setCursor] = useState(0);\r\n  const [startingCursor, setStartingCursor] = useState(0);\r\n  const prevTextRef = useRef(text);\r\n  const cursorRef = useRef(0);\r\n  const animationControlsRef = useRef<ReturnType<typeof animate> | null>(null);\r\n\r\n  // Keep cursor ref in sync\r\n  useEffect(() => {\r\n    cursorRef.current = cursor;\r\n  }, [cursor]);\r\n\r\n  useEffect(() => {\r\n    // Handle empty text\r\n    if (!text) {\r\n      setCursor(0);\r\n      setStartingCursor(0);\r\n      prevTextRef.current = '';\r\n      if (animationControlsRef.current) {\r\n        animationControlsRef.current.stop();\r\n        animationControlsRef.current = null;\r\n      }\r\n      return;\r\n    }\r\n\r\n    const prevText = prevTextRef.current;\r\n    const parts = text.split(delimiter);\r\n    \r\n    // Update starting cursor when text changes incrementally\r\n    let newStartingCursor = startingCursor;\r\n    if (prevText !== text) {\r\n      // If new text starts with previous text, continue from current cursor\r\n      // Otherwise, reset to beginning\r\n      newStartingCursor = text.startsWith(prevText) ? cursorRef.current : 0;\r\n      setStartingCursor(newStartingCursor);\r\n      prevTextRef.current = text;\r\n    }\r\n\r\n    const remainingParts = parts.length - newStartingCursor;\r\n    \r\n    if (remainingParts <= 0) {\r\n      setCursor(parts.length);\r\n      return;\r\n    }\r\n\r\n    // Stop any existing animation\r\n    if (animationControlsRef.current) {\r\n      animationControlsRef.current.stop();\r\n    }\r\n\r\n    // Calculate duration per part (in seconds) - slower for smoother animation\r\n    const durationPerPart = delimiter === \"\" ? 0.015 : // Character: 15ms per character\r\n                            delimiter === \" \" ? 0.1 : // Word: 100ms per word (smooth reading speed)\r\n                            0.4; // Chunk: 400ms per chunk\r\n    \r\n    // Total duration based on remaining parts\r\n    // Cap at reasonable maximum to avoid very long animations\r\n    const totalDuration = Math.min(remainingParts * durationPerPart, 15);\r\n    \r\n    const controls = animate(newStartingCursor, parts.length, {\r\n      duration: totalDuration,\r\n      ease: \"easeOut\",\r\n      onUpdate(latest) {\r\n        setCursor(Math.floor(latest));\r\n      },\r\n    });\r\n\r\n    animationControlsRef.current = controls;\r\n\r\n    return () => {\r\n      if (controls) {\r\n        controls.stop();\r\n      }\r\n      animationControlsRef.current = null;\r\n    };\r\n  }, [text, delimiter, startingCursor]);\r\n\r\n  return text.split(delimiter).slice(0, cursor).join(delimiter);\r\n}\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}