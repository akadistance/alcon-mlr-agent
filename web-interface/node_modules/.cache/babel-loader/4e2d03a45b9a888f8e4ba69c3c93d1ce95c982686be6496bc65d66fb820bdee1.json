{"ast":null,"code":"\"use client\";\n\nvar _s = $RefreshSig$();\nimport { animate } from \"framer-motion\";\nimport { useEffect, useState, useRef } from \"react\";\nexport function useAnimatedText(text, delimiter = \"\") {\n  _s();\n  const [cursor, setCursor] = useState(0);\n  const [startingCursor, setStartingCursor] = useState(0);\n  const prevTextRef = useRef(text);\n\n  // Update starting cursor when text changes incrementally\n  if (prevTextRef.current !== text) {\n    const prevText = prevTextRef.current;\n    // If new text starts with previous text, continue from current cursor\n    // Otherwise, reset to beginning\n    const newStartingCursor = text.startsWith(prevText) ? cursor : 0;\n    setStartingCursor(newStartingCursor);\n    prevTextRef.current = text;\n  }\n  useEffect(() => {\n    const parts = text.split(delimiter);\n    const remainingParts = parts.length - startingCursor;\n    if (remainingParts <= 0) {\n      setCursor(parts.length);\n      return;\n    }\n\n    // Calculate duration per part (in seconds)\n    const durationPerPart = delimiter === \"\" ? 0.008 :\n    // Character: 8ms per character\n    delimiter === \" \" ? 0.05 :\n    // Word: 50ms per word\n    0.2; // Chunk: 200ms per chunk\n\n    // Total duration based on remaining parts\n    const totalDuration = remainingParts * durationPerPart;\n    const controls = animate(startingCursor, parts.length, {\n      duration: totalDuration,\n      ease: \"easeOut\",\n      onUpdate(latest) {\n        setCursor(Math.floor(latest));\n      }\n    });\n    return () => controls.stop();\n  }, [startingCursor, text, delimiter, cursor]);\n  return text.split(delimiter).slice(0, cursor).join(delimiter);\n}\n_s(useAnimatedText, \"EFE+UdBAUQ83laVRmgaBgz5AN9Y=\");","map":{"version":3,"names":["_s","$RefreshSig$","animate","useEffect","useState","useRef","useAnimatedText","text","delimiter","cursor","setCursor","startingCursor","setStartingCursor","prevTextRef","current","prevText","newStartingCursor","startsWith","parts","split","remainingParts","length","durationPerPart","totalDuration","controls","duration","ease","onUpdate","latest","Math","floor","stop","slice","join"],"sources":["C:/Users/josep/OneDrive/Documents/Jason/EyeQ MLR Agent/alcon-mlr-agent/web-interface/src/components/ui/animated-text.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { animate } from \"framer-motion\";\r\nimport { useEffect, useState, useRef } from \"react\";\r\n\r\nexport function useAnimatedText(text: string, delimiter: string = \"\") {\r\n  const [cursor, setCursor] = useState(0);\r\n  const [startingCursor, setStartingCursor] = useState(0);\r\n  const prevTextRef = useRef(text);\r\n\r\n  // Update starting cursor when text changes incrementally\r\n  if (prevTextRef.current !== text) {\r\n    const prevText = prevTextRef.current;\r\n    // If new text starts with previous text, continue from current cursor\r\n    // Otherwise, reset to beginning\r\n    const newStartingCursor = text.startsWith(prevText) ? cursor : 0;\r\n    setStartingCursor(newStartingCursor);\r\n    prevTextRef.current = text;\r\n  }\r\n\r\n  useEffect(() => {\r\n    const parts = text.split(delimiter);\r\n    const remainingParts = parts.length - startingCursor;\r\n    \r\n    if (remainingParts <= 0) {\r\n      setCursor(parts.length);\r\n      return;\r\n    }\r\n\r\n    // Calculate duration per part (in seconds)\r\n    const durationPerPart = delimiter === \"\" ? 0.008 : // Character: 8ms per character\r\n                            delimiter === \" \" ? 0.05 : // Word: 50ms per word\r\n                            0.2; // Chunk: 200ms per chunk\r\n    \r\n    // Total duration based on remaining parts\r\n    const totalDuration = remainingParts * durationPerPart;\r\n    \r\n    const controls = animate(startingCursor, parts.length, {\r\n      duration: totalDuration,\r\n      ease: \"easeOut\",\r\n      onUpdate(latest) {\r\n        setCursor(Math.floor(latest));\r\n      },\r\n    });\r\n\r\n    return () => controls.stop();\r\n  }, [startingCursor, text, delimiter, cursor]);\r\n\r\n  return text.split(delimiter).slice(0, cursor).join(delimiter);\r\n}\r\n\r\n"],"mappings":"AAAA,YAAY;;AAAC,IAAAA,EAAA,GAAAC,YAAA;AAEb,SAASC,OAAO,QAAQ,eAAe;AACvC,SAASC,SAAS,EAAEC,QAAQ,EAAEC,MAAM,QAAQ,OAAO;AAEnD,OAAO,SAASC,eAAeA,CAACC,IAAY,EAAEC,SAAiB,GAAG,EAAE,EAAE;EAAAR,EAAA;EACpE,MAAM,CAACS,MAAM,EAAEC,SAAS,CAAC,GAAGN,QAAQ,CAAC,CAAC,CAAC;EACvC,MAAM,CAACO,cAAc,EAAEC,iBAAiB,CAAC,GAAGR,QAAQ,CAAC,CAAC,CAAC;EACvD,MAAMS,WAAW,GAAGR,MAAM,CAACE,IAAI,CAAC;;EAEhC;EACA,IAAIM,WAAW,CAACC,OAAO,KAAKP,IAAI,EAAE;IAChC,MAAMQ,QAAQ,GAAGF,WAAW,CAACC,OAAO;IACpC;IACA;IACA,MAAME,iBAAiB,GAAGT,IAAI,CAACU,UAAU,CAACF,QAAQ,CAAC,GAAGN,MAAM,GAAG,CAAC;IAChEG,iBAAiB,CAACI,iBAAiB,CAAC;IACpCH,WAAW,CAACC,OAAO,GAAGP,IAAI;EAC5B;EAEAJ,SAAS,CAAC,MAAM;IACd,MAAMe,KAAK,GAAGX,IAAI,CAACY,KAAK,CAACX,SAAS,CAAC;IACnC,MAAMY,cAAc,GAAGF,KAAK,CAACG,MAAM,GAAGV,cAAc;IAEpD,IAAIS,cAAc,IAAI,CAAC,EAAE;MACvBV,SAAS,CAACQ,KAAK,CAACG,MAAM,CAAC;MACvB;IACF;;IAEA;IACA,MAAMC,eAAe,GAAGd,SAAS,KAAK,EAAE,GAAG,KAAK;IAAG;IAC3BA,SAAS,KAAK,GAAG,GAAG,IAAI;IAAG;IAC3B,GAAG,CAAC,CAAC;;IAE7B;IACA,MAAMe,aAAa,GAAGH,cAAc,GAAGE,eAAe;IAEtD,MAAME,QAAQ,GAAGtB,OAAO,CAACS,cAAc,EAAEO,KAAK,CAACG,MAAM,EAAE;MACrDI,QAAQ,EAAEF,aAAa;MACvBG,IAAI,EAAE,SAAS;MACfC,QAAQA,CAACC,MAAM,EAAE;QACflB,SAAS,CAACmB,IAAI,CAACC,KAAK,CAACF,MAAM,CAAC,CAAC;MAC/B;IACF,CAAC,CAAC;IAEF,OAAO,MAAMJ,QAAQ,CAACO,IAAI,CAAC,CAAC;EAC9B,CAAC,EAAE,CAACpB,cAAc,EAAEJ,IAAI,EAAEC,SAAS,EAAEC,MAAM,CAAC,CAAC;EAE7C,OAAOF,IAAI,CAACY,KAAK,CAACX,SAAS,CAAC,CAACwB,KAAK,CAAC,CAAC,EAAEvB,MAAM,CAAC,CAACwB,IAAI,CAACzB,SAAS,CAAC;AAC/D;AAACR,EAAA,CA5CeM,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}