{"ast":null,"code":"\"use client\";\n\nvar _s = $RefreshSig$();\nimport { animate } from \"framer-motion\";\nimport { useEffect, useState, useRef } from \"react\";\nexport function useAnimatedText(text, delimiter = \"\") {\n  _s();\n  const [cursor, setCursor] = useState(0);\n  const prevTextRef = useRef(text);\n  const cursorRef = useRef(0);\n  const animationControlsRef = useRef(null);\n\n  // Keep cursor ref in sync\n  useEffect(() => {\n    cursorRef.current = cursor;\n  }, [cursor]);\n  useEffect(() => {\n    // Handle empty text - only reset if we had text before\n    if (!text) {\n      // Only reset if we previously had text (not on initial mount)\n      if (prevTextRef.current.length > 0) {\n        setCursor(0);\n        cursorRef.current = 0;\n        prevTextRef.current = '';\n        if (animationControlsRef.current) {\n          animationControlsRef.current.stop();\n          animationControlsRef.current = null;\n        }\n      }\n      return;\n    }\n    const parts = text.split(delimiter);\n    const prevText = prevTextRef.current;\n    const currentCursor = cursorRef.current;\n\n    // Determine starting point: if text continues from previous, use current cursor, otherwise reset\n    let startIndex = 0;\n    if (text.startsWith(prevText) && prevText.length > 0) {\n      // Text is incremental - continue from where we are\n      startIndex = Math.min(currentCursor, parts.length); // Don't exceed parts length\n    } else {\n      // Text is new or changed - start from beginning\n      startIndex = 0;\n      setCursor(0);\n      cursorRef.current = 0;\n    }\n    const targetIndex = parts.length;\n    const remainingParts = targetIndex - startIndex;\n\n    // If no remaining parts, we're done\n    if (remainingParts <= 0) {\n      if (cursor !== targetIndex) {\n        setCursor(targetIndex);\n        cursorRef.current = targetIndex;\n      }\n      prevTextRef.current = text;\n      return;\n    }\n\n    // Stop any existing animation\n    if (animationControlsRef.current) {\n      animationControlsRef.current.stop();\n    }\n\n    // Calculate duration per part (in seconds) - slower for visible animation\n    const durationPerPart = delimiter === \"\" ? 0.03 :\n    // Character: 30ms per character\n    delimiter === \" \" ? 0.15 :\n    // Word: 150ms per word (visible animation)\n    0.5; // Chunk: 500ms per chunk\n\n    // Duration for remaining parts - ensure minimum duration for smooth animation\n    // Cap maximum duration to avoid very long waits\n    const calculatedDuration = remainingParts * durationPerPart;\n    const duration = Math.max(Math.min(calculatedDuration, 10), 0.3);\n    const controls = animate(startIndex, targetIndex, {\n      duration: duration,\n      ease: \"easeOut\",\n      onUpdate(latest) {\n        const newCursor = Math.floor(latest);\n        setCursor(newCursor);\n        cursorRef.current = newCursor;\n      },\n      onComplete: () => {\n        // Ensure we're at the target when animation completes\n        setCursor(targetIndex);\n        cursorRef.current = targetIndex;\n      }\n    });\n    animationControlsRef.current = controls;\n    prevTextRef.current = text;\n    return () => {\n      if (controls) {\n        controls.stop();\n      }\n      animationControlsRef.current = null;\n    };\n  }, [text, delimiter]);\n  return text.split(delimiter).slice(0, cursor).join(delimiter);\n}\n_s(useAnimatedText, \"Ju+mXEUfVdoyXqX1s3LRTPZ9lxM=\");","map":{"version":3,"names":["_s","$RefreshSig$","animate","useEffect","useState","useRef","useAnimatedText","text","delimiter","cursor","setCursor","prevTextRef","cursorRef","animationControlsRef","current","length","stop","parts","split","prevText","currentCursor","startIndex","startsWith","Math","min","targetIndex","remainingParts","durationPerPart","calculatedDuration","duration","max","controls","ease","onUpdate","latest","newCursor","floor","onComplete","slice","join"],"sources":["C:/Users/josep/OneDrive/Documents/Jason/EyeQ MLR Agent/alcon-mlr-agent/web-interface/src/components/ui/animated-text.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { animate } from \"framer-motion\";\r\nimport { useEffect, useState, useRef } from \"react\";\r\n\r\nexport function useAnimatedText(text: string, delimiter: string = \"\") {\r\n  const [cursor, setCursor] = useState(0);\r\n  const prevTextRef = useRef(text);\r\n  const cursorRef = useRef(0);\r\n  const animationControlsRef = useRef<ReturnType<typeof animate> | null>(null);\r\n\r\n  // Keep cursor ref in sync\r\n  useEffect(() => {\r\n    cursorRef.current = cursor;\r\n  }, [cursor]);\r\n\r\n  useEffect(() => {\r\n    // Handle empty text - only reset if we had text before\r\n    if (!text) {\r\n      // Only reset if we previously had text (not on initial mount)\r\n      if (prevTextRef.current.length > 0) {\r\n        setCursor(0);\r\n        cursorRef.current = 0;\r\n        prevTextRef.current = '';\r\n        if (animationControlsRef.current) {\r\n          animationControlsRef.current.stop();\r\n          animationControlsRef.current = null;\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    const parts = text.split(delimiter);\r\n    const prevText = prevTextRef.current;\r\n    const currentCursor = cursorRef.current;\r\n    \r\n    // Determine starting point: if text continues from previous, use current cursor, otherwise reset\r\n    let startIndex = 0;\r\n    if (text.startsWith(prevText) && prevText.length > 0) {\r\n      // Text is incremental - continue from where we are\r\n      startIndex = Math.min(currentCursor, parts.length); // Don't exceed parts length\r\n    } else {\r\n      // Text is new or changed - start from beginning\r\n      startIndex = 0;\r\n      setCursor(0);\r\n      cursorRef.current = 0;\r\n    }\r\n\r\n    const targetIndex = parts.length;\r\n    const remainingParts = targetIndex - startIndex;\r\n    \r\n    // If no remaining parts, we're done\r\n    if (remainingParts <= 0) {\r\n      if (cursor !== targetIndex) {\r\n        setCursor(targetIndex);\r\n        cursorRef.current = targetIndex;\r\n      }\r\n      prevTextRef.current = text;\r\n      return;\r\n    }\r\n\r\n    // Stop any existing animation\r\n    if (animationControlsRef.current) {\r\n      animationControlsRef.current.stop();\r\n    }\r\n\r\n    // Calculate duration per part (in seconds) - slower for visible animation\r\n    const durationPerPart = delimiter === \"\" ? 0.03 : // Character: 30ms per character\r\n                            delimiter === \" \" ? 0.15 : // Word: 150ms per word (visible animation)\r\n                            0.5; // Chunk: 500ms per chunk\r\n    \r\n    // Duration for remaining parts - ensure minimum duration for smooth animation\r\n    // Cap maximum duration to avoid very long waits\r\n    const calculatedDuration = remainingParts * durationPerPart;\r\n    const duration = Math.max(Math.min(calculatedDuration, 10), 0.3);\r\n    \r\n    const controls = animate(startIndex, targetIndex, {\r\n      duration: duration,\r\n      ease: \"easeOut\",\r\n      onUpdate(latest) {\r\n        const newCursor = Math.floor(latest);\r\n        setCursor(newCursor);\r\n        cursorRef.current = newCursor;\r\n      },\r\n      onComplete: () => {\r\n        // Ensure we're at the target when animation completes\r\n        setCursor(targetIndex);\r\n        cursorRef.current = targetIndex;\r\n      }\r\n    });\r\n\r\n    animationControlsRef.current = controls;\r\n    prevTextRef.current = text;\r\n\r\n    return () => {\r\n      if (controls) {\r\n        controls.stop();\r\n      }\r\n      animationControlsRef.current = null;\r\n    };\r\n  }, [text, delimiter]);\r\n\r\n  return text.split(delimiter).slice(0, cursor).join(delimiter);\r\n}\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}