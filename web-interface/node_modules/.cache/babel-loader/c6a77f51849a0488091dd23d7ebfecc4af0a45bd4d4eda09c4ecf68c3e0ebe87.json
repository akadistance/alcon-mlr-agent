{"ast":null,"code":"/**\r\n * @typedef {import('mdast').Parent} MdastParent\r\n * @typedef {import('mdast').Root} Root\r\n * @typedef {import('mdast').Content} Content\r\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\r\n * @typedef {import('mdast').Text} Text\r\n * @typedef {import('unist-util-visit-parents').Test} Test\r\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\r\n */\n\n/**\r\n * @typedef {Content | Root} Node\r\n * @typedef {Extract<Node, MdastParent>} Parent\r\n * @typedef {Exclude<Parent, Root>} ContentParent\r\n *\r\n * @typedef RegExpMatchObject\r\n *   Info on the match.\r\n * @property {number} index\r\n *   The index of the search at which the result was found.\r\n * @property {string} input\r\n *   A copy of the search string in the text node.\r\n * @property {[Root, ...Array<ContentParent>, Text]} stack\r\n *   All ancestors of the text node, where the last node is the text itself.\r\n *\r\n * @callback ReplaceFunction\r\n *   Callback called when a search matches.\r\n * @param {...any} parameters\r\n *   The parameters are the result of corresponding search expression:\r\n *\r\n *   * `value` (`string`) — whole match\r\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\r\n *   * `match` (`RegExpMatchObject`) — info on the match\r\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}\r\n *   Thing to replace with.\r\n *\r\n *   * when `null`, `undefined`, `''`, remove the match\r\n *   * …or when `false`, do not replace at all\r\n *   * …or when `string`, replace with a text node of that value\r\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\r\n *\r\n * @typedef {string | RegExp} Find\r\n *   Pattern to find.\r\n *\r\n *   Strings are escaped and then turned into global expressions.\r\n *\r\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\r\n *   Several find and replaces, in array form.\r\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\r\n *   Several find and replaces, in object form.\r\n * @typedef {[Find, Replace]} FindAndReplaceTuple\r\n *   Find and replace in tuple form.\r\n * @typedef {string | ReplaceFunction} Replace\r\n *   Thing to replace with.\r\n * @typedef {[RegExp, ReplaceFunction]} Pair\r\n *   Normalized find and replace.\r\n * @typedef {Array<Pair>} Pairs\r\n *   All find and replaced.\r\n *\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {Test | null | undefined} [ignore]\r\n *   Test for which nodes to ignore.\r\n */\n\nimport escape from 'escape-string-regexp';\nimport { visitParents } from 'unist-util-visit-parents';\nimport { convert } from 'unist-util-is';\nconst own = {}.hasOwnProperty;\n\n/**\r\n * Find patterns in a tree and replace them.\r\n *\r\n * The algorithm searches the tree in *preorder* for complete values in `Text`\r\n * nodes.\r\n * Partial matches are not supported.\r\n *\r\n * @param tree\r\n *   Tree to change.\r\n * @param find\r\n *   Patterns to find.\r\n * @param replace\r\n *   Things to replace with (when `find` is `Find`) or configuration.\r\n * @param options\r\n *   Configuration (when `find` is not `Find`).\r\n * @returns\r\n *   Given, modified, tree.\r\n */\n// To do: next major: remove `find` & `replace` combo, remove schema.\nexport const findAndReplace =\n/**\r\n * @type {(\r\n *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &\r\n *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)\r\n * )}\r\n **/\n\n/**\r\n * @template {Node} Tree\r\n * @param {Tree} tree\r\n * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find\r\n * @param {Replace | Options | null | undefined} [replace]\r\n * @param {Options | null | undefined} [options]\r\n * @returns {Tree}\r\n */\nfunction (tree, find, replace, options) {\n  /** @type {Options | null | undefined} */\n  let settings;\n  /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n  let schema;\n  if (typeof find === 'string' || find instanceof RegExp) {\n    // @ts-expect-error don’t expect options twice.\n    schema = [[find, replace]];\n    settings = options;\n  } else {\n    schema = find;\n    // @ts-expect-error don’t expect replace twice.\n    settings = replace;\n  }\n  if (!settings) {\n    settings = {};\n  }\n  const ignored = convert(settings.ignore || []);\n  const pairs = toPairs(schema);\n  let pairIndex = -1;\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor);\n  }\n\n  // To do next major: don’t return the given tree.\n  return tree;\n\n  /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1;\n    /** @type {Parent | undefined} */\n    let grandparent;\n    while (++index < parents.length) {\n      const parent = parents[index];\n      if (ignored(parent,\n      // @ts-expect-error: TS doesn’t understand but it’s perfect.\n      grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {\n        return;\n      }\n      grandparent = parent;\n    }\n    if (grandparent) {\n      return handler(node, parents);\n    }\n  }\n\n  /**\r\n   * Handle a text node which is not in an ignored parent.\r\n   *\r\n   * @param {Text} node\r\n   *   Text node.\r\n   * @param {Array<Parent>} parents\r\n   *   Parents.\r\n   * @returns {VisitorResult}\r\n   *   Result.\r\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1];\n    const find = pairs[pairIndex][0];\n    const replace = pairs[pairIndex][1];\n    let start = 0;\n    // @ts-expect-error: TS is wrong, some of these children can be text.\n    const index = parent.children.indexOf(node);\n    let change = false;\n    /** @type {Array<PhrasingContent>} */\n    let nodes = [];\n    find.lastIndex = 0;\n    let match = find.exec(node.value);\n    while (match) {\n      const position = match.index;\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        // @ts-expect-error: stack is fine.\n        stack: [...parents, node]\n      };\n      let value = replace(...match, matchObject);\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {\n          type: 'text',\n          value\n        } : undefined;\n      }\n\n      // It wasn’t a match after all.\n      if (value !== false) {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          });\n        }\n        if (Array.isArray(value)) {\n          nodes.push(...value);\n        } else if (value) {\n          nodes.push(value);\n        }\n        start = position + match[0].length;\n        change = true;\n      }\n      if (!find.global) {\n        break;\n      }\n      match = find.exec(node.value);\n    }\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({\n          type: 'text',\n          value: node.value.slice(start)\n        });\n      }\n      parent.children.splice(index, 1, ...nodes);\n    } else {\n      nodes = [node];\n    }\n    return index + nodes.length;\n  }\n};\n\n/**\r\n * Turn a schema into pairs.\r\n *\r\n * @param {FindAndReplaceSchema | FindAndReplaceList} schema\r\n *   Schema.\r\n * @returns {Pairs}\r\n *   Clean pairs.\r\n */\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = [];\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema');\n  }\n  if (Array.isArray(schema)) {\n    let index = -1;\n    while (++index < schema.length) {\n      result.push([toExpression(schema[index][0]), toFunction(schema[index][1])]);\n    }\n  } else {\n    /** @type {string} */\n    let key;\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])]);\n      }\n    }\n  }\n  return result;\n}\n\n/**\r\n * Turn a find into an expression.\r\n *\r\n * @param {Find} find\r\n *   Find.\r\n * @returns {RegExp}\r\n *   Expression.\r\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find;\n}\n\n/**\r\n * Turn a replace into a function.\r\n *\r\n * @param {Replace} replace\r\n *   Replace.\r\n * @returns {ReplaceFunction}\r\n *   Function.\r\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace;\n}","map":{"version":3,"names":["escape","visitParents","convert","own","hasOwnProperty","findAndReplace","tree","find","replace","options","settings","schema","RegExp","ignored","ignore","pairs","toPairs","pairIndex","length","visitor","node","parents","index","grandparent","parent","children","indexOf","undefined","handler","start","change","nodes","lastIndex","match","exec","value","position","matchObject","input","stack","type","push","slice","Array","isArray","global","splice","result","TypeError","toExpression","toFunction","key","call"],"sources":["C:/Users/josep/OneDrive/Documents/Jason/EyeQ MLR Agent/alcon-mlr-agent/web-interface/node_modules/mdast-util-find-and-replace/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('mdast').Parent} MdastParent\r\n * @typedef {import('mdast').Root} Root\r\n * @typedef {import('mdast').Content} Content\r\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\r\n * @typedef {import('mdast').Text} Text\r\n * @typedef {import('unist-util-visit-parents').Test} Test\r\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\r\n */\r\n\r\n/**\r\n * @typedef {Content | Root} Node\r\n * @typedef {Extract<Node, MdastParent>} Parent\r\n * @typedef {Exclude<Parent, Root>} ContentParent\r\n *\r\n * @typedef RegExpMatchObject\r\n *   Info on the match.\r\n * @property {number} index\r\n *   The index of the search at which the result was found.\r\n * @property {string} input\r\n *   A copy of the search string in the text node.\r\n * @property {[Root, ...Array<ContentParent>, Text]} stack\r\n *   All ancestors of the text node, where the last node is the text itself.\r\n *\r\n * @callback ReplaceFunction\r\n *   Callback called when a search matches.\r\n * @param {...any} parameters\r\n *   The parameters are the result of corresponding search expression:\r\n *\r\n *   * `value` (`string`) — whole match\r\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\r\n *   * `match` (`RegExpMatchObject`) — info on the match\r\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}\r\n *   Thing to replace with.\r\n *\r\n *   * when `null`, `undefined`, `''`, remove the match\r\n *   * …or when `false`, do not replace at all\r\n *   * …or when `string`, replace with a text node of that value\r\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\r\n *\r\n * @typedef {string | RegExp} Find\r\n *   Pattern to find.\r\n *\r\n *   Strings are escaped and then turned into global expressions.\r\n *\r\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\r\n *   Several find and replaces, in array form.\r\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\r\n *   Several find and replaces, in object form.\r\n * @typedef {[Find, Replace]} FindAndReplaceTuple\r\n *   Find and replace in tuple form.\r\n * @typedef {string | ReplaceFunction} Replace\r\n *   Thing to replace with.\r\n * @typedef {[RegExp, ReplaceFunction]} Pair\r\n *   Normalized find and replace.\r\n * @typedef {Array<Pair>} Pairs\r\n *   All find and replaced.\r\n *\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {Test | null | undefined} [ignore]\r\n *   Test for which nodes to ignore.\r\n */\r\n\r\nimport escape from 'escape-string-regexp'\r\nimport {visitParents} from 'unist-util-visit-parents'\r\nimport {convert} from 'unist-util-is'\r\n\r\nconst own = {}.hasOwnProperty\r\n\r\n/**\r\n * Find patterns in a tree and replace them.\r\n *\r\n * The algorithm searches the tree in *preorder* for complete values in `Text`\r\n * nodes.\r\n * Partial matches are not supported.\r\n *\r\n * @param tree\r\n *   Tree to change.\r\n * @param find\r\n *   Patterns to find.\r\n * @param replace\r\n *   Things to replace with (when `find` is `Find`) or configuration.\r\n * @param options\r\n *   Configuration (when `find` is not `Find`).\r\n * @returns\r\n *   Given, modified, tree.\r\n */\r\n// To do: next major: remove `find` & `replace` combo, remove schema.\r\nexport const findAndReplace =\r\n  /**\r\n   * @type {(\r\n   *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &\r\n   *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)\r\n   * )}\r\n   **/\r\n  (\r\n    /**\r\n     * @template {Node} Tree\r\n     * @param {Tree} tree\r\n     * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find\r\n     * @param {Replace | Options | null | undefined} [replace]\r\n     * @param {Options | null | undefined} [options]\r\n     * @returns {Tree}\r\n     */\r\n    function (tree, find, replace, options) {\r\n      /** @type {Options | null | undefined} */\r\n      let settings\r\n      /** @type {FindAndReplaceSchema|FindAndReplaceList} */\r\n      let schema\r\n\r\n      if (typeof find === 'string' || find instanceof RegExp) {\r\n        // @ts-expect-error don’t expect options twice.\r\n        schema = [[find, replace]]\r\n        settings = options\r\n      } else {\r\n        schema = find\r\n        // @ts-expect-error don’t expect replace twice.\r\n        settings = replace\r\n      }\r\n\r\n      if (!settings) {\r\n        settings = {}\r\n      }\r\n\r\n      const ignored = convert(settings.ignore || [])\r\n      const pairs = toPairs(schema)\r\n      let pairIndex = -1\r\n\r\n      while (++pairIndex < pairs.length) {\r\n        visitParents(tree, 'text', visitor)\r\n      }\r\n\r\n      // To do next major: don’t return the given tree.\r\n      return tree\r\n\r\n      /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */\r\n      function visitor(node, parents) {\r\n        let index = -1\r\n        /** @type {Parent | undefined} */\r\n        let grandparent\r\n\r\n        while (++index < parents.length) {\r\n          const parent = parents[index]\r\n\r\n          if (\r\n            ignored(\r\n              parent,\r\n              // @ts-expect-error: TS doesn’t understand but it’s perfect.\r\n              grandparent ? grandparent.children.indexOf(parent) : undefined,\r\n              grandparent\r\n            )\r\n          ) {\r\n            return\r\n          }\r\n\r\n          grandparent = parent\r\n        }\r\n\r\n        if (grandparent) {\r\n          return handler(node, parents)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Handle a text node which is not in an ignored parent.\r\n       *\r\n       * @param {Text} node\r\n       *   Text node.\r\n       * @param {Array<Parent>} parents\r\n       *   Parents.\r\n       * @returns {VisitorResult}\r\n       *   Result.\r\n       */\r\n      function handler(node, parents) {\r\n        const parent = parents[parents.length - 1]\r\n        const find = pairs[pairIndex][0]\r\n        const replace = pairs[pairIndex][1]\r\n        let start = 0\r\n        // @ts-expect-error: TS is wrong, some of these children can be text.\r\n        const index = parent.children.indexOf(node)\r\n        let change = false\r\n        /** @type {Array<PhrasingContent>} */\r\n        let nodes = []\r\n\r\n        find.lastIndex = 0\r\n\r\n        let match = find.exec(node.value)\r\n\r\n        while (match) {\r\n          const position = match.index\r\n          /** @type {RegExpMatchObject} */\r\n          const matchObject = {\r\n            index: match.index,\r\n            input: match.input,\r\n            // @ts-expect-error: stack is fine.\r\n            stack: [...parents, node]\r\n          }\r\n          let value = replace(...match, matchObject)\r\n\r\n          if (typeof value === 'string') {\r\n            value = value.length > 0 ? {type: 'text', value} : undefined\r\n          }\r\n\r\n          // It wasn’t a match after all.\r\n          if (value !== false) {\r\n            if (start !== position) {\r\n              nodes.push({\r\n                type: 'text',\r\n                value: node.value.slice(start, position)\r\n              })\r\n            }\r\n\r\n            if (Array.isArray(value)) {\r\n              nodes.push(...value)\r\n            } else if (value) {\r\n              nodes.push(value)\r\n            }\r\n\r\n            start = position + match[0].length\r\n            change = true\r\n          }\r\n\r\n          if (!find.global) {\r\n            break\r\n          }\r\n\r\n          match = find.exec(node.value)\r\n        }\r\n\r\n        if (change) {\r\n          if (start < node.value.length) {\r\n            nodes.push({type: 'text', value: node.value.slice(start)})\r\n          }\r\n\r\n          parent.children.splice(index, 1, ...nodes)\r\n        } else {\r\n          nodes = [node]\r\n        }\r\n\r\n        return index + nodes.length\r\n      }\r\n    }\r\n  )\r\n\r\n/**\r\n * Turn a schema into pairs.\r\n *\r\n * @param {FindAndReplaceSchema | FindAndReplaceList} schema\r\n *   Schema.\r\n * @returns {Pairs}\r\n *   Clean pairs.\r\n */\r\nfunction toPairs(schema) {\r\n  /** @type {Pairs} */\r\n  const result = []\r\n\r\n  if (typeof schema !== 'object') {\r\n    throw new TypeError('Expected array or object as schema')\r\n  }\r\n\r\n  if (Array.isArray(schema)) {\r\n    let index = -1\r\n\r\n    while (++index < schema.length) {\r\n      result.push([\r\n        toExpression(schema[index][0]),\r\n        toFunction(schema[index][1])\r\n      ])\r\n    }\r\n  } else {\r\n    /** @type {string} */\r\n    let key\r\n\r\n    for (key in schema) {\r\n      if (own.call(schema, key)) {\r\n        result.push([toExpression(key), toFunction(schema[key])])\r\n      }\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Turn a find into an expression.\r\n *\r\n * @param {Find} find\r\n *   Find.\r\n * @returns {RegExp}\r\n *   Expression.\r\n */\r\nfunction toExpression(find) {\r\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\r\n}\r\n\r\n/**\r\n * Turn a replace into a function.\r\n *\r\n * @param {Replace} replace\r\n *   Replace.\r\n * @returns {ReplaceFunction}\r\n *   Function.\r\n */\r\nfunction toFunction(replace) {\r\n  return typeof replace === 'function' ? replace : () => replace\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}