{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\josep\\\\OneDrive\\\\Documents\\\\Jason\\\\EyeQ MLR Agent\\\\alcon-mlr-agent\\\\web-interface\\\\src\\\\ChatContext.tsx\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ChatContext = /*#__PURE__*/createContext({\n  conversations: [],\n  currentConversationId: null,\n  createNewConversation: () => null,\n  createConversationOnFirstMessage: () => '',\n  getCurrentConversation: () => ({\n    id: '',\n    title: '',\n    messages: [],\n    pinned: false,\n    createdAt: new Date(),\n    updatedAt: new Date()\n  }),\n  updateCurrentMessages: () => {},\n  switchConversation: () => {},\n  updateConversationTitle: () => {},\n  uploadedFiles: [],\n  addFile: async () => ({\n    id: '',\n    name: '',\n    size: 0,\n    type: '',\n    uploaded_at: '',\n    content: '',\n    isLocal: true\n  }),\n  deleteFile: async () => {},\n  sortedConversations: [],\n  deleteConversation: async () => {},\n  renameConversation: () => {},\n  toggleConversationPin: () => {},\n  clearAllConversations: () => {},\n  exportConversation: () => {}\n});\n\n// LocalStorage helper functions\nconst STORAGE_KEYS = {\n  CONVERSATIONS: 'eyeq_conversations',\n  CURRENT_CONVERSATION: 'eyeq_current_conversation'\n};\nconst saveToLocalStorage = (key, data) => {\n  // Check if we're in a browser environment (not during build)\n  if (typeof window === 'undefined' || typeof localStorage === 'undefined') {\n    return;\n  }\n  try {\n    localStorage.setItem(key, JSON.stringify(data));\n  } catch (error) {\n    console.warn('Failed to save to localStorage:', error);\n  }\n};\nconst loadFromLocalStorage = (key, defaultValue = null) => {\n  // Check if we're in a browser environment (not during build)\n  if (typeof window === 'undefined' || typeof localStorage === 'undefined') {\n    return defaultValue;\n  }\n  try {\n    const item = localStorage.getItem(key);\n    return item ? JSON.parse(item) : defaultValue;\n  } catch (error) {\n    console.warn('Failed to load from localStorage:', error);\n    return defaultValue;\n  }\n};\nexport const ChatProvider = ({\n  children\n}) => {\n  _s();\n  // Start with empty conversations - load from localStorage but don't auto-create\n  const [conversations, setConversations] = useState(() => {\n    const local = loadFromLocalStorage(STORAGE_KEYS.CONVERSATIONS, []);\n    return local && Array.isArray(local) && local.length > 0 ? local : [];\n  });\n  // Start with no current conversation (homepage state)\n  const [currentConversationId, setCurrentConversationId] = useState(null);\n  const [uploadedFiles, setUploadedFiles] = useState([]);\n\n  // Load data from localStorage on initialization - but DON'T restore current conversation\n  useEffect(() => {\n    console.log('ðŸ ChatContext useEffect running - loading data from localStorage');\n    const loadData = () => {\n      try {\n        // Load conversations from localStorage (files are not stored)\n        const localConversations = loadFromLocalStorage(STORAGE_KEYS.CONVERSATIONS, []) || [];\n        console.log('Loaded conversations from localStorage:', localConversations.length);\n        setConversations(localConversations);\n        // Always start with empty files array - files are not persisted\n        setUploadedFiles([]);\n\n        // ALWAYS start with null (homepage) - don't restore previous conversation\n        setCurrentConversationId(null);\n        // Clear the saved current conversation\n        if (typeof window !== 'undefined' && typeof localStorage !== 'undefined') {\n          localStorage.removeItem(STORAGE_KEYS.CURRENT_CONVERSATION);\n          // Clean up any old files from localStorage if they exist\n          localStorage.removeItem('eyeq_files');\n        }\n        console.log('ðŸ  Starting on homepage (no current conversation)');\n      } catch (error) {\n        console.error('Error loading data from localStorage:', error);\n        setConversations([]);\n        setUploadedFiles([]);\n        setCurrentConversationId(null);\n      }\n    };\n    loadData();\n  }, []);\n\n  // Save conversations to localStorage\n  const saveConversationsToLocal = conversationsToSave => {\n    console.log('Saving conversations to localStorage:', conversationsToSave.length);\n    saveToLocalStorage(STORAGE_KEYS.CONVERSATIONS, conversationsToSave);\n  };\n  const createNewConversation = () => {\n    // If we're already on homepage (no current conversation), don't create a new one\n    if (!currentConversationId) {\n      console.log('ðŸ  Already on homepage, no need to create new conversation');\n      return null;\n    }\n\n    // Check if current conversation is empty - if so, just clear to homepage\n    const currentConv = conversations.find(c => c.id === currentConversationId);\n    if (currentConv && currentConv.messages.length === 0) {\n      console.log('ðŸ  Current conversation is empty, returning to homepage');\n      setCurrentConversationId(null);\n      return null;\n    }\n\n    // If current conversation has messages, return to homepage (don't create new conversation yet)\n    console.log('ðŸ  Returning to homepage');\n    setCurrentConversationId(null);\n    return null;\n  };\n  const createConversationOnFirstMessage = () => {\n    // Create conversation only when user sends first message\n    const newId = Date.now().toString();\n    const nowDate = new Date();\n    const newConversations = [...conversations, {\n      id: newId,\n      title: 'New Chat',\n      messages: [],\n      pinned: false,\n      createdAt: nowDate,\n      updatedAt: nowDate\n    }];\n    setConversations(newConversations);\n    setCurrentConversationId(newId);\n    saveConversationsToLocal(newConversations);\n    console.log('âœ¨ Created new conversation on first message:', newId);\n    return newId;\n  };\n  const getCurrentConversation = () => {\n    const found = conversations.find(conv => conv.id === currentConversationId);\n    return found || {\n      id: '',\n      title: '',\n      messages: [],\n      pinned: false,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n  };\n\n  // Debounce timer ref for localStorage saves during streaming\n  const saveTimeoutRef = React.useRef(null);\n  const updateCurrentMessages = (newMessages, targetConversationId = null) => {\n    // Use provided conversationId or fall back to currentConversationId\n    const conversationIdToUpdate = targetConversationId || currentConversationId;\n    if (!conversationIdToUpdate) {\n      console.error('âŒ No conversation ID to update messages for!');\n      return;\n    }\n\n    // Check if any message is currently streaming - if so, defer localStorage save\n    const isStreaming = newMessages.some(msg => msg.isStreaming === true);\n    setConversations(prevConversations => {\n      const updatedConversations = prevConversations.map(conv => {\n        if (conv.id === conversationIdToUpdate) {\n          return {\n            ...conv,\n            messages: [...newMessages],\n            updatedAt: new Date()\n          };\n        }\n        return conv;\n      });\n\n      // Only save to localStorage if NOT streaming, or debounce if streaming\n      if (!isStreaming) {\n        // Clear any pending save timeout\n        if (saveTimeoutRef.current) {\n          clearTimeout(saveTimeoutRef.current);\n          saveTimeoutRef.current = null;\n        }\n        saveConversationsToLocal(updatedConversations);\n      } else {\n        // During streaming, debounce saves to every 500ms to avoid blocking UI\n        if (saveTimeoutRef.current) {\n          clearTimeout(saveTimeoutRef.current);\n        }\n        saveTimeoutRef.current = setTimeout(() => {\n          saveConversationsToLocal(updatedConversations);\n          saveTimeoutRef.current = null;\n        }, 500);\n      }\n\n      // Auto-rename conversation based on first user message\n      const currentConv = updatedConversations.find(conv => conv.id === conversationIdToUpdate);\n      if (currentConv && currentConv.title === 'New Chat' && newMessages.length > 0) {\n        const firstUserMessage = newMessages.find(msg => msg.type === 'user');\n        if (firstUserMessage) {\n          const title = generateTitleFromMessage(firstUserMessage.content);\n          // Use setTimeout to avoid calling updateConversationTitle during render\n          setTimeout(() => updateConversationTitle(conversationIdToUpdate, title), 0);\n        }\n      }\n      return updatedConversations;\n    });\n  };\n  const generateTitleFromMessage = message => {\n    // Extract meaningful title from message (first 50 chars, clean up)\n    let title = message.trim();\n\n    // Remove common prefixes\n    title = title.replace(/^(please|can you|could you|help me|i need|analyze|review|check)/i, '');\n    title = title.trim();\n\n    // Truncate and clean up\n    if (title.length > 50) {\n      title = title.substring(0, 47) + '...';\n    }\n\n    // Capitalize first letter\n    title = title.charAt(0).toUpperCase() + title.slice(1);\n    return title || 'New Chat';\n  };\n  const switchConversation = id => {\n    setCurrentConversationId(id);\n    // Only save to localStorage if in browser environment\n    if (typeof window !== 'undefined' && typeof localStorage !== 'undefined') {\n      saveToLocalStorage(STORAGE_KEYS.CURRENT_CONVERSATION, id);\n    }\n  };\n  const updateConversationTitle = (id, title) => {\n    console.log('updateConversationTitle called with:', {\n      id,\n      title,\n      currentConversationId\n    });\n    setConversations(prevConversations => {\n      const updatedConversations = prevConversations.map(conv => conv.id === id ? {\n        ...conv,\n        title\n      } : conv);\n      console.log('Updated conversations after title change:', updatedConversations);\n      saveConversationsToLocal(updatedConversations);\n      return updatedConversations;\n    });\n  };\n  const addFile = async file => {\n    try {\n      // Create file object (NOT stored in localStorage - files are temporary)\n      const fileData = {\n        id: Date.now().toString(),\n        name: file.name,\n        size: file.size,\n        type: file.type,\n        uploaded_at: new Date().toISOString(),\n        content: '',\n        // Will be filled by backend processing\n        isLocal: true\n      };\n\n      // Add to local state only (not persisted to localStorage)\n      const updatedFiles = [...uploadedFiles, fileData];\n      setUploadedFiles(updatedFiles);\n      console.log('File added (temporary, not stored):', file.name);\n      return fileData;\n    } catch (error) {\n      console.error('Failed to add file:', error);\n      throw error;\n    }\n  };\n  const deleteFile = async fileId => {\n    try {\n      // Remove from local state only (files are not persisted)\n      const updatedFiles = uploadedFiles.filter(file => file.id !== fileId);\n      setUploadedFiles(updatedFiles);\n      console.log('File deleted (temporary):', fileId);\n    } catch (error) {\n      console.error('Failed to delete file:', error);\n      throw error;\n    }\n  };\n  const deleteConversation = async id => {\n    setConversations(prevConversations => {\n      const updatedConversations = prevConversations.filter(conv => conv.id !== id);\n      if (currentConversationId === id) {\n        var _updatedConversations;\n        setCurrentConversationId(((_updatedConversations = updatedConversations[0]) === null || _updatedConversations === void 0 ? void 0 : _updatedConversations.id) || null);\n      }\n\n      // Save to localStorage\n      saveConversationsToLocal(updatedConversations);\n      return updatedConversations;\n    });\n  };\n  const renameConversation = (id, newTitle) => {\n    setConversations(prevConversations => {\n      const updatedConversations = prevConversations.map(conv => conv.id === id ? {\n        ...conv,\n        title: newTitle\n      } : conv);\n      saveConversationsToLocal(updatedConversations);\n      return updatedConversations;\n    });\n  };\n  const toggleConversationPin = id => {\n    setConversations(prevConversations => {\n      const updatedConversations = prevConversations.map(conv => conv.id === id ? {\n        ...conv,\n        pinned: !conv.pinned\n      } : conv);\n      saveConversationsToLocal(updatedConversations);\n      return updatedConversations;\n    });\n  };\n  const clearAllConversations = () => {\n    setConversations([]);\n    setCurrentConversationId(null);\n  };\n  const exportConversation = id => {\n    const conv = conversations.find(c => c.id === id);\n    if (conv) {\n      const data = JSON.stringify(conv);\n      const blob = new Blob([data], {\n        type: 'application/json'\n      });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `${conv.title}.json`;\n      a.click();\n      URL.revokeObjectURL(url);\n    }\n  };\n\n  // Sort conversations with pinned first\n  const sortedConversations = [...conversations].sort((a, b) => (b.pinned ? 1 : 0) - (a.pinned ? 1 : 0));\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      conversations,\n      currentConversationId,\n      createNewConversation,\n      createConversationOnFirstMessage,\n      getCurrentConversation,\n      updateCurrentMessages,\n      switchConversation,\n      updateConversationTitle,\n      uploadedFiles,\n      addFile,\n      deleteFile,\n      sortedConversations,\n      deleteConversation,\n      renameConversation,\n      toggleConversationPin,\n      clearAllConversations,\n      exportConversation\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 370,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatProvider, \"RBSkNLCGDsvhvQfg5SWxex3Ih9c=\");\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","jsxDEV","_jsxDEV","ChatContext","conversations","currentConversationId","createNewConversation","createConversationOnFirstMessage","getCurrentConversation","id","title","messages","pinned","createdAt","Date","updatedAt","updateCurrentMessages","switchConversation","updateConversationTitle","uploadedFiles","addFile","name","size","type","uploaded_at","content","isLocal","deleteFile","sortedConversations","deleteConversation","renameConversation","toggleConversationPin","clearAllConversations","exportConversation","STORAGE_KEYS","CONVERSATIONS","CURRENT_CONVERSATION","saveToLocalStorage","key","data","window","localStorage","setItem","JSON","stringify","error","console","warn","loadFromLocalStorage","defaultValue","item","getItem","parse","ChatProvider","children","_s","setConversations","local","Array","isArray","length","setCurrentConversationId","setUploadedFiles","log","loadData","localConversations","removeItem","saveConversationsToLocal","conversationsToSave","currentConv","find","c","newId","now","toString","nowDate","newConversations","found","conv","saveTimeoutRef","useRef","newMessages","targetConversationId","conversationIdToUpdate","isStreaming","some","msg","prevConversations","updatedConversations","map","current","clearTimeout","setTimeout","firstUserMessage","generateTitleFromMessage","message","trim","replace","substring","charAt","toUpperCase","slice","file","fileData","toISOString","updatedFiles","fileId","filter","_updatedConversations","newTitle","blob","Blob","url","URL","createObjectURL","a","document","createElement","href","download","click","revokeObjectURL","sort","b","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/josep/OneDrive/Documents/Jason/EyeQ MLR Agent/alcon-mlr-agent/web-interface/src/ChatContext.tsx"],"sourcesContent":["import React, { createContext, useState, useEffect, ReactNode } from 'react';\r\nimport { Message, Conversation, UploadedFile } from './types';\r\n\r\ninterface ChatContextType {\r\n  conversations: Conversation[];\r\n  currentConversationId: string | null;\r\n  createNewConversation: () => string | null;\r\n  createConversationOnFirstMessage: () => string;\r\n  getCurrentConversation: () => Conversation;\r\n  updateCurrentMessages: (newMessages: Message[], targetConversationId?: string | null) => void;\r\n  switchConversation: (id: string) => void;\r\n  updateConversationTitle: (id: string, title: string) => void;\r\n  uploadedFiles: UploadedFile[];\r\n  addFile: (file: File) => Promise<UploadedFile>;\r\n  deleteFile: (fileId: string) => Promise<void>;\r\n  sortedConversations: Conversation[];\r\n  deleteConversation: (id: string) => Promise<void>;\r\n  renameConversation: (id: string, newTitle: string) => void;\r\n  toggleConversationPin: (id: string) => void;\r\n  clearAllConversations: () => void;\r\n  exportConversation: (id: string) => void;\r\n}\r\n\r\nexport const ChatContext = createContext<ChatContextType>({\r\n  conversations: [],\r\n  currentConversationId: null,\r\n  createNewConversation: () => null,\r\n  createConversationOnFirstMessage: () => '',\r\n  getCurrentConversation: () => ({ id: '', title: '', messages: [], pinned: false, createdAt: new Date(), updatedAt: new Date() }),\r\n  updateCurrentMessages: () => {},\r\n  switchConversation: () => {},\r\n  updateConversationTitle: () => {},\r\n  uploadedFiles: [],\r\n  addFile: async () => ({ id: '', name: '', size: 0, type: '', uploaded_at: '', content: '', isLocal: true }),\r\n  deleteFile: async () => {},\r\n  sortedConversations: [],\r\n  deleteConversation: async () => {},\r\n  renameConversation: () => {},\r\n  toggleConversationPin: () => {},\r\n  clearAllConversations: () => {},\r\n  exportConversation: () => {},\r\n});\r\n\r\n// LocalStorage helper functions\r\nconst STORAGE_KEYS = {\r\n  CONVERSATIONS: 'eyeq_conversations',\r\n  CURRENT_CONVERSATION: 'eyeq_current_conversation'\r\n};\r\n\r\nconst saveToLocalStorage = (key: string, data: any) => {\r\n  // Check if we're in a browser environment (not during build)\r\n  if (typeof window === 'undefined' || typeof localStorage === 'undefined') {\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    localStorage.setItem(key, JSON.stringify(data));\r\n  } catch (error) {\r\n    console.warn('Failed to save to localStorage:', error);\r\n  }\r\n};\r\n\r\nconst loadFromLocalStorage = <T,>(key: string, defaultValue: T | null = null): T | null => {\r\n  // Check if we're in a browser environment (not during build)\r\n  if (typeof window === 'undefined' || typeof localStorage === 'undefined') {\r\n    return defaultValue;\r\n  }\r\n  \r\n  try {\r\n    const item = localStorage.getItem(key);\r\n    return item ? JSON.parse(item) : defaultValue;\r\n  } catch (error) {\r\n    console.warn('Failed to load from localStorage:', error);\r\n    return defaultValue;\r\n  }\r\n};\r\n\r\ninterface ChatProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\nexport const ChatProvider: React.FC<ChatProviderProps> = ({ children }) => {\r\n  // Start with empty conversations - load from localStorage but don't auto-create\r\n  const [conversations, setConversations] = useState<Conversation[]>(() => {\r\n    const local = loadFromLocalStorage<Conversation[]>(STORAGE_KEYS.CONVERSATIONS, []);\r\n    return (local && Array.isArray(local) && local.length > 0) ? local : [];\r\n  });\r\n  // Start with no current conversation (homepage state)\r\n  const [currentConversationId, setCurrentConversationId] = useState<string | null>(null);\r\n  const [uploadedFiles, setUploadedFiles] = useState<UploadedFile[]>([]);\r\n\r\n  // Load data from localStorage on initialization - but DON'T restore current conversation\r\n  useEffect(() => {\r\n    console.log('ðŸ ChatContext useEffect running - loading data from localStorage');\r\n    const loadData = () => {\r\n      try {\r\n        // Load conversations from localStorage (files are not stored)\r\n        const localConversations = loadFromLocalStorage<Conversation[]>(STORAGE_KEYS.CONVERSATIONS, []) || [];\r\n        \r\n        console.log('Loaded conversations from localStorage:', localConversations.length);\r\n        \r\n        setConversations(localConversations);\r\n        // Always start with empty files array - files are not persisted\r\n        setUploadedFiles([]);\r\n        \r\n        // ALWAYS start with null (homepage) - don't restore previous conversation\r\n        setCurrentConversationId(null);\r\n        // Clear the saved current conversation\r\n        if (typeof window !== 'undefined' && typeof localStorage !== 'undefined') {\r\n          localStorage.removeItem(STORAGE_KEYS.CURRENT_CONVERSATION);\r\n          // Clean up any old files from localStorage if they exist\r\n          localStorage.removeItem('eyeq_files');\r\n        }\r\n        \r\n        console.log('ðŸ  Starting on homepage (no current conversation)');\r\n        \r\n      } catch (error) {\r\n        console.error('Error loading data from localStorage:', error);\r\n        setConversations([]);\r\n        setUploadedFiles([]);\r\n        setCurrentConversationId(null);\r\n      }\r\n    };\r\n    \r\n    loadData();\r\n  }, []);\r\n\r\n  // Save conversations to localStorage\r\n  const saveConversationsToLocal = (conversationsToSave: Conversation[]) => {\r\n    console.log('Saving conversations to localStorage:', conversationsToSave.length);\r\n    saveToLocalStorage(STORAGE_KEYS.CONVERSATIONS, conversationsToSave);\r\n  };\r\n\r\n  const createNewConversation = (): string | null => {\r\n    // If we're already on homepage (no current conversation), don't create a new one\r\n    if (!currentConversationId) {\r\n      console.log('ðŸ  Already on homepage, no need to create new conversation');\r\n      return null;\r\n    }\r\n    \r\n    // Check if current conversation is empty - if so, just clear to homepage\r\n    const currentConv = conversations.find(c => c.id === currentConversationId);\r\n    if (currentConv && currentConv.messages.length === 0) {\r\n      console.log('ðŸ  Current conversation is empty, returning to homepage');\r\n      setCurrentConversationId(null);\r\n      return null;\r\n    }\r\n    \r\n    // If current conversation has messages, return to homepage (don't create new conversation yet)\r\n    console.log('ðŸ  Returning to homepage');\r\n    setCurrentConversationId(null);\r\n    return null;\r\n  };\r\n  \r\n  const createConversationOnFirstMessage = (): string => {\r\n    // Create conversation only when user sends first message\r\n    const newId = Date.now().toString();\r\n    const nowDate = new Date();\r\n    const newConversations: Conversation[] = [...conversations, { \r\n      id: newId, \r\n      title: 'New Chat', \r\n      messages: [], \r\n      pinned: false, \r\n      createdAt: nowDate, \r\n      updatedAt: nowDate\r\n    }];\r\n    setConversations(newConversations);\r\n    setCurrentConversationId(newId);\r\n    saveConversationsToLocal(newConversations);\r\n    console.log('âœ¨ Created new conversation on first message:', newId);\r\n    return newId;\r\n  };\r\n\r\n  const getCurrentConversation = (): Conversation => {\r\n    const found = conversations.find(conv => conv.id === currentConversationId);\r\n    return found || { id: '', title: '', messages: [], pinned: false, createdAt: new Date(), updatedAt: new Date() };\r\n  };\r\n\r\n  // Debounce timer ref for localStorage saves during streaming\r\n  const saveTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);\r\n\r\n  const updateCurrentMessages = (newMessages: Message[], targetConversationId: string | null = null) => {\r\n    // Use provided conversationId or fall back to currentConversationId\r\n    const conversationIdToUpdate = targetConversationId || currentConversationId;\r\n    \r\n    if (!conversationIdToUpdate) {\r\n      console.error('âŒ No conversation ID to update messages for!');\r\n      return;\r\n    }\r\n    \r\n    // Check if any message is currently streaming - if so, defer localStorage save\r\n    const isStreaming = newMessages.some(msg => (msg as any).isStreaming === true);\r\n    \r\n    setConversations(prevConversations => {\r\n      const updatedConversations = prevConversations.map(conv => {\r\n        if (conv.id === conversationIdToUpdate) {\r\n          return { ...conv, messages: [...newMessages], updatedAt: new Date() };\r\n        }\r\n        return conv;\r\n      });\r\n      \r\n      // Only save to localStorage if NOT streaming, or debounce if streaming\r\n      if (!isStreaming) {\r\n        // Clear any pending save timeout\r\n        if (saveTimeoutRef.current) {\r\n          clearTimeout(saveTimeoutRef.current);\r\n          saveTimeoutRef.current = null;\r\n        }\r\n        saveConversationsToLocal(updatedConversations);\r\n      } else {\r\n        // During streaming, debounce saves to every 500ms to avoid blocking UI\r\n        if (saveTimeoutRef.current) {\r\n          clearTimeout(saveTimeoutRef.current);\r\n        }\r\n        saveTimeoutRef.current = setTimeout(() => {\r\n          saveConversationsToLocal(updatedConversations);\r\n          saveTimeoutRef.current = null;\r\n        }, 500);\r\n      }\r\n      \r\n      // Auto-rename conversation based on first user message\r\n      const currentConv = updatedConversations.find(conv => conv.id === conversationIdToUpdate);\r\n      if (currentConv && currentConv.title === 'New Chat' && newMessages.length > 0) {\r\n        const firstUserMessage = newMessages.find(msg => msg.type === 'user');\r\n        if (firstUserMessage) {\r\n          const title = generateTitleFromMessage(firstUserMessage.content);\r\n          // Use setTimeout to avoid calling updateConversationTitle during render\r\n          setTimeout(() => updateConversationTitle(conversationIdToUpdate, title), 0);\r\n        }\r\n      }\r\n      \r\n      return updatedConversations;\r\n    });\r\n  };\r\n\r\n  const generateTitleFromMessage = (message: string): string => {\r\n    // Extract meaningful title from message (first 50 chars, clean up)\r\n    let title = message.trim();\r\n    \r\n    // Remove common prefixes\r\n    title = title.replace(/^(please|can you|could you|help me|i need|analyze|review|check)/i, '');\r\n    title = title.trim();\r\n    \r\n    // Truncate and clean up\r\n    if (title.length > 50) {\r\n      title = title.substring(0, 47) + '...';\r\n    }\r\n    \r\n    // Capitalize first letter\r\n    title = title.charAt(0).toUpperCase() + title.slice(1);\r\n    \r\n    return title || 'New Chat';\r\n  };\r\n\r\n  const switchConversation = (id: string) => {\r\n    setCurrentConversationId(id);\r\n    // Only save to localStorage if in browser environment\r\n    if (typeof window !== 'undefined' && typeof localStorage !== 'undefined') {\r\n      saveToLocalStorage(STORAGE_KEYS.CURRENT_CONVERSATION, id);\r\n    }\r\n  };\r\n\r\n  const updateConversationTitle = (id: string, title: string) => {\r\n    console.log('updateConversationTitle called with:', { id, title, currentConversationId });\r\n    setConversations(prevConversations => {\r\n      const updatedConversations = prevConversations.map(conv => \r\n        conv.id === id ? { ...conv, title } : conv\r\n      );\r\n      console.log('Updated conversations after title change:', updatedConversations);\r\n      saveConversationsToLocal(updatedConversations);\r\n      return updatedConversations;\r\n    });\r\n  };\r\n\r\n  const addFile = async (file: File): Promise<UploadedFile> => {\r\n    try {\r\n      // Create file object (NOT stored in localStorage - files are temporary)\r\n      const fileData: UploadedFile = {\r\n        id: Date.now().toString(),\r\n        name: file.name,\r\n        size: file.size,\r\n        type: file.type,\r\n        uploaded_at: new Date().toISOString(),\r\n        content: '', // Will be filled by backend processing\r\n        isLocal: true\r\n      };\r\n      \r\n      // Add to local state only (not persisted to localStorage)\r\n      const updatedFiles = [...uploadedFiles, fileData];\r\n      setUploadedFiles(updatedFiles);\r\n      \r\n      console.log('File added (temporary, not stored):', file.name);\r\n      return fileData;\r\n    } catch (error) {\r\n      console.error('Failed to add file:', error);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const deleteFile = async (fileId: string): Promise<void> => {\r\n    try {\r\n      // Remove from local state only (files are not persisted)\r\n      const updatedFiles = uploadedFiles.filter(file => file.id !== fileId);\r\n      setUploadedFiles(updatedFiles);\r\n      \r\n      console.log('File deleted (temporary):', fileId);\r\n    } catch (error) {\r\n      console.error('Failed to delete file:', error);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const deleteConversation = async (id: string): Promise<void> => {\r\n    setConversations(prevConversations => {\r\n      const updatedConversations = prevConversations.filter(conv => conv.id !== id);\r\n      \r\n      if (currentConversationId === id) {\r\n        setCurrentConversationId(updatedConversations[0]?.id || null);\r\n      }\r\n      \r\n      // Save to localStorage\r\n      saveConversationsToLocal(updatedConversations);\r\n      return updatedConversations;\r\n    });\r\n  };\r\n\r\n  const renameConversation = (id: string, newTitle: string) => {\r\n    setConversations(prevConversations => {\r\n      const updatedConversations = prevConversations.map(conv => \r\n        conv.id === id ? { ...conv, title: newTitle } : conv\r\n      );\r\n      saveConversationsToLocal(updatedConversations);\r\n      return updatedConversations;\r\n    });\r\n  };\r\n\r\n  const toggleConversationPin = (id: string) => {\r\n    setConversations(prevConversations => {\r\n      const updatedConversations = prevConversations.map(conv => \r\n        conv.id === id ? { ...conv, pinned: !conv.pinned } : conv\r\n      );\r\n      saveConversationsToLocal(updatedConversations);\r\n      return updatedConversations;\r\n    });\r\n  };\r\n\r\n  const clearAllConversations = () => {\r\n    setConversations([]);\r\n    setCurrentConversationId(null);\r\n  };\r\n\r\n  const exportConversation = (id: string) => {\r\n    const conv = conversations.find(c => c.id === id);\r\n    if (conv) {\r\n      const data = JSON.stringify(conv);\r\n      const blob = new Blob([data], { type: 'application/json' });\r\n      const url = URL.createObjectURL(blob);\r\n      const a = document.createElement('a');\r\n      a.href = url;\r\n      a.download = `${conv.title}.json`;\r\n      a.click();\r\n      URL.revokeObjectURL(url);\r\n    }\r\n  };\r\n\r\n  // Sort conversations with pinned first\r\n  const sortedConversations = [...conversations].sort((a, b) => (b.pinned ? 1 : 0) - (a.pinned ? 1 : 0));\r\n\r\n  return (\r\n    <ChatContext.Provider value={{\r\n      conversations,\r\n      currentConversationId,\r\n      createNewConversation,\r\n      createConversationOnFirstMessage,\r\n      getCurrentConversation,\r\n      updateCurrentMessages,\r\n      switchConversation,\r\n      updateConversationTitle,\r\n      uploadedFiles,\r\n      addFile,\r\n      deleteFile,\r\n      sortedConversations,\r\n      deleteConversation,\r\n      renameConversation,\r\n      toggleConversationPin,\r\n      clearAllConversations,\r\n      exportConversation\r\n    }}>\r\n      {children}\r\n    </ChatContext.Provider>\r\n  );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}