{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\n\n/**\n * Hook to animate text streaming character-by-character or word-by-word\n * Supports incremental updates for streaming text with smart cursor tracking\n * @param text - The full text to animate (can be incrementally updated)\n * @param delimiter - The delimiter to split by (e.g., \" \" for words, \"\" for characters, \"\\n\\n\" for paragraphs)\n * @param delay - Delay in milliseconds between each chunk (optional, defaults to calculated duration)\n * @returns The currently displayed animated text\n */\nexport function useAnimatedText(text, delimiter = \"\", delay) {\n  _s();\n  const [cursor, setCursor] = useState(0);\n  const [startingCursor, setStartingCursor] = useState(0);\n  const prevTextRef = useRef(text);\n  const timeoutRef = useRef(null);\n  const isAnimatingRef = useRef(false);\n\n  // Update starting cursor when text changes incrementally\n  if (prevTextRef.current !== text) {\n    const prevText = prevTextRef.current;\n    // If new text starts with previous text, continue from current cursor\n    // Otherwise, reset to beginning\n    const newStartingCursor = text.startsWith(prevText) ? cursor : 0;\n    setStartingCursor(newStartingCursor);\n    prevTextRef.current = text;\n  }\n  useEffect(() => {\n    const parts = text.split(delimiter);\n\n    // Calculate duration based on delimiter type if delay not provided\n    const calculatedDuration = delay !== undefined ? delay * parts.length : delimiter === \"\" ? 8 // Character animation - 8ms total per character\n    : delimiter === \" \" ? 4 // Word animation - 4ms total per word\n    : 2; // Chunk animation - 2ms total per chunk\n\n    // Calculate delay per chunk\n    const delayPerChunk = delay !== undefined ? delay : parts.length > 0 ? calculatedDuration / parts.length : 20;\n\n    // Stop any existing animation\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n    isAnimatingRef.current = false;\n\n    // If we're already at the end, don't animate\n    if (startingCursor >= parts.length) {\n      setCursor(parts.length);\n      return;\n    }\n\n    // Start animation from startingCursor\n    let currentIndex = startingCursor;\n    isAnimatingRef.current = true;\n    const animate = () => {\n      if (currentIndex < parts.length && isAnimatingRef.current) {\n        setCursor(currentIndex + 1);\n        currentIndex++;\n        if (currentIndex < parts.length) {\n          timeoutRef.current = setTimeout(animate, delayPerChunk);\n        } else {\n          isAnimatingRef.current = false;\n        }\n      } else {\n        isAnimatingRef.current = false;\n      }\n    };\n\n    // Start animation\n    animate();\n\n    // Cleanup\n    return () => {\n      isAnimatingRef.current = false;\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n    };\n  }, [startingCursor, text, delimiter, delay]);\n  return text.split(delimiter).slice(0, cursor).join(delimiter);\n}\n_s(useAnimatedText, \"SybDcrrN4LuBYUGcAw06xO6JniY=\");","map":{"version":3,"names":["useState","useEffect","useRef","useAnimatedText","text","delimiter","delay","_s","cursor","setCursor","startingCursor","setStartingCursor","prevTextRef","timeoutRef","isAnimatingRef","current","prevText","newStartingCursor","startsWith","parts","split","calculatedDuration","undefined","length","delayPerChunk","clearTimeout","currentIndex","animate","setTimeout","slice","join"],"sources":["C:/Users/josep/OneDrive/Documents/Jason/EyeQ MLR Agent/alcon-mlr-agent/web-interface/src/components/ui/animated-text.tsx"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\n\n/**\n * Hook to animate text streaming character-by-character or word-by-word\n * Supports incremental updates for streaming text with smart cursor tracking\n * @param text - The full text to animate (can be incrementally updated)\n * @param delimiter - The delimiter to split by (e.g., \" \" for words, \"\" for characters, \"\\n\\n\" for paragraphs)\n * @param delay - Delay in milliseconds between each chunk (optional, defaults to calculated duration)\n * @returns The currently displayed animated text\n */\nexport function useAnimatedText(\n  text: string,\n  delimiter: string = \"\",\n  delay?: number\n): string {\n  const [cursor, setCursor] = useState(0);\n  const [startingCursor, setStartingCursor] = useState(0);\n  const prevTextRef = useRef(text);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const isAnimatingRef = useRef(false);\n\n  // Update starting cursor when text changes incrementally\n  if (prevTextRef.current !== text) {\n    const prevText = prevTextRef.current;\n    // If new text starts with previous text, continue from current cursor\n    // Otherwise, reset to beginning\n    const newStartingCursor = text.startsWith(prevText) ? cursor : 0;\n    setStartingCursor(newStartingCursor);\n    prevTextRef.current = text;\n  }\n\n  useEffect(() => {\n    const parts = text.split(delimiter);\n    \n    // Calculate duration based on delimiter type if delay not provided\n    const calculatedDuration = delay !== undefined \n      ? delay * parts.length \n      : delimiter === \"\" \n        ? 8  // Character animation - 8ms total per character\n        : delimiter === \" \" \n          ? 4  // Word animation - 4ms total per word\n          : 2; // Chunk animation - 2ms total per chunk\n    \n    // Calculate delay per chunk\n    const delayPerChunk = delay !== undefined \n      ? delay \n      : parts.length > 0 \n        ? calculatedDuration / parts.length \n        : 20;\n\n    // Stop any existing animation\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n    isAnimatingRef.current = false;\n\n    // If we're already at the end, don't animate\n    if (startingCursor >= parts.length) {\n      setCursor(parts.length);\n      return;\n    }\n\n    // Start animation from startingCursor\n    let currentIndex = startingCursor;\n    isAnimatingRef.current = true;\n\n    const animate = () => {\n      if (currentIndex < parts.length && isAnimatingRef.current) {\n        setCursor(currentIndex + 1);\n        currentIndex++;\n        \n        if (currentIndex < parts.length) {\n          timeoutRef.current = setTimeout(animate, delayPerChunk);\n        } else {\n          isAnimatingRef.current = false;\n        }\n      } else {\n        isAnimatingRef.current = false;\n      }\n    };\n\n    // Start animation\n    animate();\n\n    // Cleanup\n    return () => {\n      isAnimatingRef.current = false;\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n    };\n  }, [startingCursor, text, delimiter, delay]);\n\n  return text.split(delimiter).slice(0, cursor).join(delimiter);\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}