{"ast":null,"code":"\"use client\";\n\nvar _s = $RefreshSig$();\nimport { animate } from \"framer-motion\";\nimport { useEffect, useState, useRef } from \"react\";\nexport function useAnimatedText(text, delimiter = \"\") {\n  _s();\n  const [cursor, setCursor] = useState(0);\n  const prevTextRef = useRef(text);\n  const prevPartsLengthRef = useRef(0);\n  const animationControlsRef = useRef(null);\n  useEffect(() => {\n    // Handle empty text\n    if (!text) {\n      setCursor(0);\n      prevTextRef.current = '';\n      prevPartsLengthRef.current = 0;\n      if (animationControlsRef.current) {\n        animationControlsRef.current.stop();\n        animationControlsRef.current = null;\n      }\n      return;\n    }\n    const parts = text.split(delimiter);\n    const prevText = prevTextRef.current;\n    const prevPartsLength = prevPartsLengthRef.current;\n\n    // Determine starting point: if text continues from previous, use current cursor, otherwise reset\n    const startIndex = text.startsWith(prevText) ? cursor : 0;\n    const newPartsCount = parts.length - prevPartsLength;\n\n    // If no new parts, just ensure cursor is at the end\n    if (newPartsCount <= 0 && parts.length > 0) {\n      if (cursor < parts.length) {\n        setCursor(parts.length);\n      }\n      prevTextRef.current = text;\n      prevPartsLengthRef.current = parts.length;\n      return;\n    }\n\n    // Stop any existing animation\n    if (animationControlsRef.current) {\n      animationControlsRef.current.stop();\n    }\n\n    // Calculate duration per part (in seconds)\n    const durationPerPart = delimiter === \"\" ? 0.02 :\n    // Character: 20ms per character\n    delimiter === \" \" ? 0.12 :\n    // Word: 120ms per word\n    0.5; // Chunk: 500ms per chunk\n\n    // Only animate the new parts, not all remaining parts\n    // This prevents re-animating text that's already been displayed\n    const targetIndex = startIndex + newPartsCount;\n    const duration = Math.max(newPartsCount * durationPerPart, 0.2);\n    const controls = animate(startIndex, targetIndex, {\n      duration: duration,\n      ease: \"easeOut\",\n      onUpdate(latest) {\n        setCursor(Math.floor(latest));\n      },\n      onComplete: () => {\n        // Ensure we're at the target when animation completes\n        setCursor(targetIndex);\n      }\n    });\n    animationControlsRef.current = controls;\n    prevTextRef.current = text;\n    prevPartsLengthRef.current = parts.length;\n    return () => {\n      if (controls) {\n        controls.stop();\n      }\n      animationControlsRef.current = null;\n    };\n  }, [text, delimiter, cursor]);\n  return text.split(delimiter).slice(0, cursor).join(delimiter);\n}\n_s(useAnimatedText, \"Jw7EzfzN2vZx1b1SKWOCQptd9fs=\");","map":{"version":3,"names":["_s","$RefreshSig$","animate","useEffect","useState","useRef","useAnimatedText","text","delimiter","cursor","setCursor","prevTextRef","prevPartsLengthRef","animationControlsRef","current","stop","parts","split","prevText","prevPartsLength","startIndex","startsWith","newPartsCount","length","durationPerPart","targetIndex","duration","Math","max","controls","ease","onUpdate","latest","floor","onComplete","slice","join"],"sources":["C:/Users/josep/OneDrive/Documents/Jason/EyeQ MLR Agent/alcon-mlr-agent/web-interface/src/components/ui/animated-text.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { animate } from \"framer-motion\";\r\nimport { useEffect, useState, useRef } from \"react\";\r\n\r\nexport function useAnimatedText(text: string, delimiter: string = \"\") {\r\n  const [cursor, setCursor] = useState(0);\r\n  const prevTextRef = useRef(text);\r\n  const prevPartsLengthRef = useRef(0);\r\n  const animationControlsRef = useRef<ReturnType<typeof animate> | null>(null);\r\n\r\n  useEffect(() => {\r\n    // Handle empty text\r\n    if (!text) {\r\n      setCursor(0);\r\n      prevTextRef.current = '';\r\n      prevPartsLengthRef.current = 0;\r\n      if (animationControlsRef.current) {\r\n        animationControlsRef.current.stop();\r\n        animationControlsRef.current = null;\r\n      }\r\n      return;\r\n    }\r\n\r\n    const parts = text.split(delimiter);\r\n    const prevText = prevTextRef.current;\r\n    const prevPartsLength = prevPartsLengthRef.current;\r\n    \r\n    // Determine starting point: if text continues from previous, use current cursor, otherwise reset\r\n    const startIndex = text.startsWith(prevText) ? cursor : 0;\r\n    const newPartsCount = parts.length - prevPartsLength;\r\n    \r\n    // If no new parts, just ensure cursor is at the end\r\n    if (newPartsCount <= 0 && parts.length > 0) {\r\n      if (cursor < parts.length) {\r\n        setCursor(parts.length);\r\n      }\r\n      prevTextRef.current = text;\r\n      prevPartsLengthRef.current = parts.length;\r\n      return;\r\n    }\r\n\r\n    // Stop any existing animation\r\n    if (animationControlsRef.current) {\r\n      animationControlsRef.current.stop();\r\n    }\r\n\r\n    // Calculate duration per part (in seconds)\r\n    const durationPerPart = delimiter === \"\" ? 0.02 : // Character: 20ms per character\r\n                            delimiter === \" \" ? 0.12 : // Word: 120ms per word\r\n                            0.5; // Chunk: 500ms per chunk\r\n    \r\n    // Only animate the new parts, not all remaining parts\r\n    // This prevents re-animating text that's already been displayed\r\n    const targetIndex = startIndex + newPartsCount;\r\n    const duration = Math.max(newPartsCount * durationPerPart, 0.2);\r\n    \r\n    const controls = animate(startIndex, targetIndex, {\r\n      duration: duration,\r\n      ease: \"easeOut\",\r\n      onUpdate(latest) {\r\n        setCursor(Math.floor(latest));\r\n      },\r\n      onComplete: () => {\r\n        // Ensure we're at the target when animation completes\r\n        setCursor(targetIndex);\r\n      }\r\n    });\r\n\r\n    animationControlsRef.current = controls;\r\n    prevTextRef.current = text;\r\n    prevPartsLengthRef.current = parts.length;\r\n\r\n    return () => {\r\n      if (controls) {\r\n        controls.stop();\r\n      }\r\n      animationControlsRef.current = null;\r\n    };\r\n  }, [text, delimiter, cursor]);\r\n\r\n  return text.split(delimiter).slice(0, cursor).join(delimiter);\r\n}\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}