{"ast":null,"code":"\"use client\";\n\nvar _s = $RefreshSig$();\nimport { animate } from \"framer-motion\";\nimport { useEffect, useState, useRef } from \"react\";\nexport function useAnimatedText(text, delimiter = \"\") {\n  _s();\n  const [displayedText, setDisplayedText] = useState(\"\");\n  const prevTextRef = useRef(\"\");\n  const animationControlsRef = useRef(null);\n  const isAnimatingRef = useRef(false);\n  useEffect(() => {\n    // Handle empty text\n    if (!text) {\n      if (prevTextRef.current.length > 0) {\n        setDisplayedText(\"\");\n        prevTextRef.current = \"\";\n        if (animationControlsRef.current) {\n          animationControlsRef.current.stop();\n          animationControlsRef.current = null;\n        }\n        isAnimatingRef.current = false;\n      }\n      return;\n    }\n\n    // If text hasn't changed, do nothing\n    if (text === prevTextRef.current) {\n      return;\n    }\n    const prevText = prevTextRef.current;\n    const currentDisplayed = displayedText;\n\n    // Check if this is incremental text (new text starts with previous)\n    if (text.startsWith(prevText) && prevText.length > 0) {\n      // Incremental update - only animate the NEW part\n      const newText = text.slice(prevText.length);\n      const newParts = newText.split(delimiter).filter(p => p.length > 0);\n      if (newParts.length === 0) {\n        // No new parts, just update ref\n        prevTextRef.current = text;\n        return;\n      }\n\n      // Calculate how many words we've already displayed\n      const displayedParts = currentDisplayed.split(delimiter).filter(p => p.length > 0);\n      const totalParts = text.split(delimiter).filter(p => p.length > 0);\n\n      // Start from where we are, animate to the new end\n      const startIndex = displayedParts.length;\n      const targetIndex = totalParts.length;\n      const newPartsCount = targetIndex - startIndex;\n      if (newPartsCount <= 0) {\n        prevTextRef.current = text;\n        return;\n      }\n\n      // Stop existing animation\n      if (animationControlsRef.current) {\n        animationControlsRef.current.stop();\n      }\n\n      // Calculate duration - animate new words at a readable pace\n      const durationPerPart = delimiter === \"\" ? 0.02 :\n      // Character: 20ms\n      delimiter === \" \" ? 0.15 :\n      // Word: 150ms per word\n      0.3; // Chunk: 300ms\n\n      const duration = Math.max(newPartsCount * durationPerPart, 0.2);\n      console.log(`[AnimatedText] Animating ${newPartsCount} new parts (${startIndex} -> ${targetIndex}), duration: ${duration.toFixed(2)}s`);\n      isAnimatingRef.current = true;\n      const controls = animate(startIndex, targetIndex, {\n        duration: duration,\n        ease: \"linear\",\n        // Linear for consistent word-by-word display\n        onUpdate(latest) {\n          const currentIndex = Math.floor(latest);\n          const parts = text.split(delimiter).filter(p => p.length > 0);\n          const newDisplayed = parts.slice(0, currentIndex).join(delimiter);\n          setDisplayedText(newDisplayed);\n        },\n        onComplete: () => {\n          // Ensure we show the full text when animation completes\n          setDisplayedText(text);\n          isAnimatingRef.current = false;\n          console.log(`[AnimatedText] Animation complete, displayed ${targetIndex} parts`);\n        }\n      });\n      animationControlsRef.current = controls;\n      prevTextRef.current = text;\n      return () => {\n        if (controls) {\n          controls.stop();\n        }\n        animationControlsRef.current = null;\n        isAnimatingRef.current = false;\n      };\n    } else {\n      // New text (not incremental) - start from beginning\n      const parts = text.split(delimiter).filter(p => p.length > 0);\n      if (parts.length === 0) {\n        setDisplayedText(\"\");\n        prevTextRef.current = text;\n        return;\n      }\n\n      // Stop existing animation\n      if (animationControlsRef.current) {\n        animationControlsRef.current.stop();\n      }\n\n      // Animate from 0 to full length\n      const durationPerPart = delimiter === \"\" ? 0.02 : delimiter === \" \" ? 0.15 : 0.3;\n      const duration = Math.max(parts.length * durationPerPart, 0.2);\n      console.log(`[AnimatedText] New text, animating ${parts.length} parts, duration: ${duration.toFixed(2)}s`);\n      isAnimatingRef.current = true;\n      const controls = animate(0, parts.length, {\n        duration: duration,\n        ease: \"linear\",\n        onUpdate(latest) {\n          const currentIndex = Math.floor(latest);\n          const newDisplayed = parts.slice(0, currentIndex).join(delimiter);\n          setDisplayedText(newDisplayed);\n        },\n        onComplete: () => {\n          setDisplayedText(text);\n          isAnimatingRef.current = false;\n        }\n      });\n      animationControlsRef.current = controls;\n      prevTextRef.current = text;\n      return () => {\n        if (controls) {\n          controls.stop();\n        }\n        animationControlsRef.current = null;\n        isAnimatingRef.current = false;\n      };\n    }\n  }, [text, delimiter, displayedText]);\n  return displayedText;\n}\n_s(useAnimatedText, \"Q2JaYWGdjHhOoVDQa1phYhpscRk=\");","map":{"version":3,"names":["_s","$RefreshSig$","animate","useEffect","useState","useRef","useAnimatedText","text","delimiter","displayedText","setDisplayedText","prevTextRef","animationControlsRef","isAnimatingRef","current","length","stop","prevText","currentDisplayed","startsWith","newText","slice","newParts","split","filter","p","displayedParts","totalParts","startIndex","targetIndex","newPartsCount","durationPerPart","duration","Math","max","console","log","toFixed","controls","ease","onUpdate","latest","currentIndex","floor","parts","newDisplayed","join","onComplete"],"sources":["C:/Users/josep/OneDrive/Documents/Jason/EyeQ MLR Agent/alcon-mlr-agent/web-interface/src/components/ui/animated-text.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { animate } from \"framer-motion\";\r\nimport { useEffect, useState, useRef } from \"react\";\r\n\r\nexport function useAnimatedText(text: string, delimiter: string = \"\") {\r\n  const [displayedText, setDisplayedText] = useState(\"\");\r\n  const prevTextRef = useRef(\"\");\r\n  const animationControlsRef = useRef<ReturnType<typeof animate> | null>(null);\r\n  const isAnimatingRef = useRef(false);\r\n\r\n  useEffect(() => {\r\n    // Handle empty text\r\n    if (!text) {\r\n      if (prevTextRef.current.length > 0) {\r\n        setDisplayedText(\"\");\r\n        prevTextRef.current = \"\";\r\n        if (animationControlsRef.current) {\r\n          animationControlsRef.current.stop();\r\n          animationControlsRef.current = null;\r\n        }\r\n        isAnimatingRef.current = false;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // If text hasn't changed, do nothing\r\n    if (text === prevTextRef.current) {\r\n      return;\r\n    }\r\n\r\n    const prevText = prevTextRef.current;\r\n    const currentDisplayed = displayedText;\r\n\r\n    // Check if this is incremental text (new text starts with previous)\r\n    if (text.startsWith(prevText) && prevText.length > 0) {\r\n      // Incremental update - only animate the NEW part\r\n      const newText = text.slice(prevText.length);\r\n      const newParts = newText.split(delimiter).filter(p => p.length > 0);\r\n      \r\n      if (newParts.length === 0) {\r\n        // No new parts, just update ref\r\n        prevTextRef.current = text;\r\n        return;\r\n      }\r\n\r\n      // Calculate how many words we've already displayed\r\n      const displayedParts = currentDisplayed.split(delimiter).filter(p => p.length > 0);\r\n      const totalParts = text.split(delimiter).filter(p => p.length > 0);\r\n      \r\n      // Start from where we are, animate to the new end\r\n      const startIndex = displayedParts.length;\r\n      const targetIndex = totalParts.length;\r\n      const newPartsCount = targetIndex - startIndex;\r\n\r\n      if (newPartsCount <= 0) {\r\n        prevTextRef.current = text;\r\n        return;\r\n      }\r\n\r\n      // Stop existing animation\r\n      if (animationControlsRef.current) {\r\n        animationControlsRef.current.stop();\r\n      }\r\n\r\n      // Calculate duration - animate new words at a readable pace\r\n      const durationPerPart = delimiter === \"\" ? 0.02 : // Character: 20ms\r\n                              delimiter === \" \" ? 0.15 : // Word: 150ms per word\r\n                              0.3; // Chunk: 300ms\r\n      \r\n      const duration = Math.max(newPartsCount * durationPerPart, 0.2);\r\n      \r\n      console.log(`[AnimatedText] Animating ${newPartsCount} new parts (${startIndex} -> ${targetIndex}), duration: ${duration.toFixed(2)}s`);\r\n\r\n      isAnimatingRef.current = true;\r\n      \r\n      const controls = animate(startIndex, targetIndex, {\r\n        duration: duration,\r\n        ease: \"linear\", // Linear for consistent word-by-word display\r\n        onUpdate(latest) {\r\n          const currentIndex = Math.floor(latest);\r\n          const parts = text.split(delimiter).filter(p => p.length > 0);\r\n          const newDisplayed = parts.slice(0, currentIndex).join(delimiter);\r\n          setDisplayedText(newDisplayed);\r\n        },\r\n        onComplete: () => {\r\n          // Ensure we show the full text when animation completes\r\n          setDisplayedText(text);\r\n          isAnimatingRef.current = false;\r\n          console.log(`[AnimatedText] Animation complete, displayed ${targetIndex} parts`);\r\n        }\r\n      });\r\n\r\n      animationControlsRef.current = controls;\r\n      prevTextRef.current = text;\r\n\r\n      return () => {\r\n        if (controls) {\r\n          controls.stop();\r\n        }\r\n        animationControlsRef.current = null;\r\n        isAnimatingRef.current = false;\r\n      };\r\n    } else {\r\n      // New text (not incremental) - start from beginning\r\n      const parts = text.split(delimiter).filter(p => p.length > 0);\r\n      \r\n      if (parts.length === 0) {\r\n        setDisplayedText(\"\");\r\n        prevTextRef.current = text;\r\n        return;\r\n      }\r\n\r\n      // Stop existing animation\r\n      if (animationControlsRef.current) {\r\n        animationControlsRef.current.stop();\r\n      }\r\n\r\n      // Animate from 0 to full length\r\n      const durationPerPart = delimiter === \"\" ? 0.02 :\r\n                              delimiter === \" \" ? 0.15 :\r\n                              0.3;\r\n      \r\n      const duration = Math.max(parts.length * durationPerPart, 0.2);\r\n      \r\n      console.log(`[AnimatedText] New text, animating ${parts.length} parts, duration: ${duration.toFixed(2)}s`);\r\n\r\n      isAnimatingRef.current = true;\r\n      \r\n      const controls = animate(0, parts.length, {\r\n        duration: duration,\r\n        ease: \"linear\",\r\n        onUpdate(latest) {\r\n          const currentIndex = Math.floor(latest);\r\n          const newDisplayed = parts.slice(0, currentIndex).join(delimiter);\r\n          setDisplayedText(newDisplayed);\r\n        },\r\n        onComplete: () => {\r\n          setDisplayedText(text);\r\n          isAnimatingRef.current = false;\r\n        }\r\n      });\r\n\r\n      animationControlsRef.current = controls;\r\n      prevTextRef.current = text;\r\n\r\n      return () => {\r\n        if (controls) {\r\n          controls.stop();\r\n        }\r\n        animationControlsRef.current = null;\r\n        isAnimatingRef.current = false;\r\n      };\r\n    }\r\n  }, [text, delimiter, displayedText]);\r\n\r\n  return displayedText;\r\n}\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}